#+TITLE: Patrones de Diseño 2.0
#+STARTUP: inlineimages
#+BEGIN_COMMENT
  Dudas
  1. Cada *concrete command* actuaría como un pequeño adapter entre el Invoker y el receptor?
#+END_COMMENT
* Usando
   1. https://github.com/torokmark/design_patterns_in_typescript
   2. http://www.design-patterns-stories.com/patterns/Facade/
   3. https://www.programcreek.com/2013/02/java-design-pattern-facade/
   4. https://reactiveprogramming.io/blog/es/patrones-de-diseno/facade
   5. https://www.programmergirl.com/java-facade-pattern/
   6. https://softwaredevelopmenttricky.blogspot.com/2017/12/facade-pattern.html
   7. https://java-white-box.blogspot.com/2014/10/patrones-de-diseno-patron-adapter.html?view=snapshot
   8. https://medium.com/flutter-community/flutter-design-patterns-2-adapter-3f05c02a7c84
   9. https://sites.google.com/a/dotnetlead.com/home/design-patterns/facade

   Otros
   1. https://www.cs.unc.edu/~stotts/GOF/hires/pat4efso.htm
   2. http://blog.lukaszewski.it/2013/08/31/design-patterns-facade/
   3. http://codejavu.blogspot.com/2013/08/ejemplo-patron-adapter.html
   4. https://java-white-box.blogspot.com/?view=snapshot
   5. http://micaminomaster.com.co/arquitectura-software/patron-adapter/
* Diferencias entre Patrones
** Facade Vs. Adapter
   #+BEGIN_QUOTE
   In the adapter pattern, we try to alter an interface so that the clients is able to work with the system.
   Else the system will be difficult to use by the client (even not usable).

   The facade pattern simplifies the interface. It presents the client with a simple interface to interact with (instead of a complex subsystem).
   #+END_QUOTE

   #+NAME: diferencia-facade-adapter
   |-------------------------------------------------------------------+-------------------------------------------------------------------------|
   | *FACADE*                                                          | *ADAPTER*                                                               |
   |-------------------------------------------------------------------+-------------------------------------------------------------------------|
   | Agrupa/reduce varios métodos de varios objetos en un único método | Renombra los métodos y parámetros de un objeto (**Adaptee**)            |
   |-------------------------------------------------------------------+-------------------------------------------------------------------------|
   | Simplifica y oculta el uso de varios subsistemas/servicios        | Adapta los mensajes de un objeto a una interfaz particular (**Target**) |
   |-------------------------------------------------------------------+-------------------------------------------------------------------------|

   #+BEGIN_SRC plantuml :file diagramas-de-clases/facade-vs-adapter.png :exports results
     @startuml
     Title Patrón Adapter Vs. Patrón Facade

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón Facade (simplicidad - agrupa servicios)"{
         class Oficina <<Client>>
    
         class ServicioImpresionFachada <<Facade>>{
             -Documento doc
             -ServicioFirmar servicio1
             -ServicioValidar servicio2
             -ServicioImprimir servicio3
             +void imprimirFirmadoValidado()
         }
    
         class ServicioValidar <<Service>>{
             +void validar(Documento doc)
         }
    
         class ServicioFirmar <<Service>>{
             +void firmar(Documento doc)
         }    
    
         class ServicioImprimir <<Service>>{
             +void imprimir(Documento doc)
         }    
    
         note right of ServicioImpresionFachada
         La fachada agrupa todos los servicios
         para que la oficina solo utilice la
         función **imprimirFirmadoValidado()**
         ocultando lógica que no necesita conocer
         end note
     }

     package "Patrón Adapter (adaptar interfaces incompatibles)"{

         component "Reproductor Estandar"{
             interface IReproductor <<Adaptee>>{
                 +void reproducirMP4(String archivo)
                 +void reproducirMPG(String archivo)
             }
        
             class ReproductorMP4{
                 +void reproducirMP4(String archivo)
                 +void reproducirMPG(String archivo)
             }
        
             class ReproductorMPG{
                 +void reproducirMP4(String archivo)
                 +void reproducirMPG(String archivo)
             }
         }
    
         interface IMiniReproductor <<Target>>{
             +void reproducir(String formato, String archivo)
         }

         class MiniReproductor {
             -ReproductorAdapter reproductorAdapter
             +void reproducir(String formato, String archivo)
         }
    
         class ReproductorAdapter <<Adapter>>{
             +void reproducir(String formato, String archivo)
         }

         note top of ReproductorAdapter
         Se busca que el **MiniReproductor** pueda usar nuevos
         formatos de audio (MP4 y MPG) además del que tiene

         Se crea un adapter como puente entre las interfaces incompatibles.
         Para que las interfaz **IReproductor** de los reproductores 
         de MP4 y MPG sea compatible con la del **MiniReproductor**
         ya que entienden otros mensajes **reproducirMP4()** y **reproducirMPG()**
         end note

     }

     ' =====================
     ' ==== RELACIONES =====
     ' =====================

     Oficina                     -right-> ServicioImpresionFachada
     ServicioImpresionFachada    -down-> ServicioValidar
     ServicioImpresionFachada    -down-> ServicioFirmar
     ServicioImpresionFachada    -down-> ServicioImprimir

     ReproductorMP4              .up.|> IReproductor : implementa
     ReproductorMPG              .up.|> IReproductor : implementa

     ReproductorAdapter        -down-> IReproductor
     ReproductorAdapter        .up.|> IMiniReproductor
     MiniReproductor             .up.|> IMiniReproductor

     MiniReproductor             -right-> ReproductorAdapter : usa



     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/facade-vs-adapter.png]]

** Factory Method Vs. Builder
*** Method Factory
    En el *method factory* se pasa por parámetro tipo de objeto que se quiere, sin tanto nivel de detalle, y se obtiene en un solo paso.
    Ej. ~transporteFactory.getTransporte('Avion')~
*** Builder
    - En el **builder** se describe el paso paso de la construcción de un objeto complejo y se obtiene luego del último paso.
    - Tiene más nivel de detalle que **factory method**
    - Permite una **interfáz fluida** con una **encadenamiento de métodos** esto sería si retornamos el mismo tipo de objeto en c/paso ~a().b().c()~
    
    Ej. ~new Bebida().setServir("coco").setPrecio(500).withAzucar().crear()~
*** Diagramas de clases
    #+BEGIN_SRC plantuml :file diagramas-de-clases/factory-vs-buildery.png :exports results
      @startuml
      Title Patrón Builder Vs. Factory Method

      ' ================
      ' ==== CLASES ====
      ' ================

      package "Patrón Builder"{
          abstract class BebidaBuilder{
              #bebida
              +{abstract} void servir()
              +{abstract} void calentarAgua()
              +{abstract} void agregarExtras()
              +void preparar()
              +void crearBebida()
              +Bebida getBebida()
          }
    
          class CafeBuilder <<Concrete Builder>>{
              +void servir()
              +void calentarAgua()
              +void agregarExtras()
          }
    
          class TeBuilder  <<Concrete Builder>>{
              +void servir()
              +void calentarAgua()
              +void agregarExtras()
          }
    
          class Bebida <<Product>>{
              -int temperatura
              -String tipo
              -TamanioVaso tamanio
          }
    
          note as N1
          En el **builder** se describe el paso paso
          de la construcción de un objeto complejo y
          se obtiene luego del último paso.
          Tiene más nivel de detalle que **factory method**
    
          Permite una **interfáz fluida** con una **encadenamiento de métodos**
          esto sería si retornamos el mismo tipo de objeto en c/paso a().b().c()
    
          Ej. new Bebida().setServir("coco").setPrecio(500).withAzucar().crear()
          end note
    
          N1 .up.  CafeBuilder
          N1 .up.  TeBuilder

      }

      package "Patrón Method Factory"{
          interface ITransporteFactory <<Creator>>{
              +Transporte getTransporte(String tipo)
          }
    
          class TransporteFactory <<Concrete Creator>>{
          +Transporte getTransporte(String tipo)
          }
    
    
          interface Transporte <<Product>>{
              +void reparar()
              +void conducir()
              +double costo()
          }
    
          class Avion <<Concrete Product>>{
              +void reparar()
              +void conducir()
              +double costo()
          }
    
          class Tren <<Concrete Product>>{
              +void reparar()
              +void conducir()
              +double costo()
          }
    
          note bottom of TransporteFactory
          En el **method factory** se pasa por parámetro
          tipo de objeto que se quiere, sin tanto nivel 
          de detalle, y se obtiene en un solo paso.
    
          Ej. transporteFactory.getTransporte('Avion')
          end note
      }

      ' ================
      ' == RELACIONES ==
      ' ================

      together {
      TeBuilder       -u-|> BebidaBuilder
      CafeBuilder     -u-|> BebidaBuilder
      BebidaBuilder   -r->  Bebida
      }

      Avion       .up.|> Transporte
      Tren        .up.|> Transporte
      NullTransporte   .left.|> Transporte

      TransporteFactory   .up.|> ITransporteFactory
      ITransporteFactory .right.> Transporte
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:diagramas-de-clases/factory-vs-buildery.png]]
** Strategy Vs. Template Method
*** Template Method
   - Se basa en la *herencia*
   - Define una clase con un plantilla de operaciones que usarán las subclases (entienden los mismos mensajes)
   - La clase-padre reutiliza las operaciones en un método (no es necesario que estén en un orden específico)
   - Cuando multiples clases tienen igual comportamiento/lógica usamos la herencia evitando tener la misma lógica repartida en varias clases.
*** Strategy
    - Se basa en la *composición*
    - Cada *estrategia concreta* es un algoritmo independiente, y el *contexto* puede intercambiar entre ellas (/en tiempo de ejecución/)
*** Tabla Comparativa
   |------------------------------------------------------------+--------------------------------------------------------------------|
   | *STRATEGY (estrategia)*                                    | *TEMPLATE METHOD (método plantilla)*                               |
   |------------------------------------------------------------+--------------------------------------------------------------------|
   | Usa *Composición*                                          | Usa *Herencia*                                                     |
   |------------------------------------------------------------+--------------------------------------------------------------------|
   | Encapsula *comportamiento* (delega en c/clase)             | Reparte *comportamiento* (plantilla, que usan todas las subclases) |
   |------------------------------------------------------------+--------------------------------------------------------------------|
   |                                                            | Tiene un método que reutiliza lógica de las subclases              |
   |------------------------------------------------------------+--------------------------------------------------------------------|
   | Cambia de *estado* de forma dinámica (tiempo de ejecución) |                                                                    |
   |------------------------------------------------------------+--------------------------------------------------------------------|
*** Diagrama de clases
    #+BEGIN_SRC plantuml :file diagramas-de-clases/template-method-vs-strategy.png :exports results
      @startuml
      Title Template Method Vs. Strategy

      ' ================
      ' ==== CLASES ====
      ' ================

      package "Template Method"{
          abstract class AccesoWeb{
              -String usuario
              -String clave
              +void validarCuenta()
              +{abstract} void obtenerDatos()
              +{abstract} boolean validarPermisos()
              +{abstract} void mostrarPagina()
          }
    
          class AccesoPremium{
              +void obtenerDatos()
              +boolean validarPermisos()
              +void mostrarPagina()
          }
    
          class AccesoGratuito{
              +void obtenerDatos()
              +boolean validarPermisos()
              +void mostrarPagina()
          }
    
          note as N1
          Ataca la repetición de código, por tanto las clases 
          comparten información (por usar **herencia**)
    
          El algoritmo necesita de varias operaciones/pasos 
          (que pueden ya tener comportamiento definido),
          y delega en las subclases que lo terminen.
    
          La superclase reutiliza las operaciones en un método.
          end note
    
          N1 .up. AccesoPremium
          N1 .up. AccesoGratuito

      }

      rectangle "Context" as A{
          abstract class Jugador{
              -String nombre
              -Tiro tipoTiro
              +void realizarTiro()
              +void setTiro(Tiro tipoTiro)
          }

          class Arquero{
              +void disparar()
          }

          class Soldado{
              +void disparar()
          }
    
      }

      package "Patrón Strategy " as B{
          interface Tiro <<Strategy>>{
              +void realizarTiro()
          }

          class TiroPreciso <<Concrete Strategy>>{
              +void realizarTiro()
          }
          class TiroMortal <<Concrete Strategy>>{
              +void realizarTiro()
          }
    
          note as N2
          Cada estrategia concreta (es un algoritmo) NO comparte
          información, son independientes.
    
          El **contexto** puede intercambiar facilmente entre las
          estrategias en tiempo de ejecución (por usar **composición**)
          end note
    
          N2 .up. TiroPreciso
          N2 .up. TiroMortal
      }


      Arquero -u-|> Jugador
      Soldado -u-|> Jugador

      TiroPreciso .u.|> Tiro
      TiroMortal .u.|> Tiro


      Jugador::tipoTiro -r-> Tiro : delega en

      ' ================
      ' == RELACIONES ==
      ' ================

      AccesoPremium   -u-|> AccesoWeb
      AccesoGratuito  -u-|> AccesoWeb

      ' ================
      ' ==== NOTAS =====
      ' ================

      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:diagramas-de-clases/template-method-vs-strategy.png]]
** State Vs. Strategy
*** En común
    - El diagrama de UML es el mismo
*** Objetivo que persiguen
   - El *Strategy* define una _familia de algoritmos_ que tienen el mismo objetivo (/Ej. estimar un precio, ordenamiento, .../)
   - El *State* define _estados completamente DIFERENTES_
*** Cambio de estado/Transiciones
   - En el *Stragy* el *Client* solo puede alternar entre ellos _explícitamente_
   - En el *State* puede alternar _explictamente_ pero también _implícitamente_ porque _un estado puede tener el comportamiento de cambiar a otro estado_
     porque pueden estar conectados entre ellos (o no) y definir transiciones como una AF _máquina de estados finito_ A->B->A->B->C->...
** [TODO] Template Method Vs. Builder
   |----------------------------------+----------------------------------------------|
   | *TEMPLATE METHOD*                | *BUILDER*                                    |
   |----------------------------------+----------------------------------------------|
   | no necesita de un orden de pasos | requiere una secuencia de pasos (1,2,3,..)   |
   |----------------------------------+----------------------------------------------|
   | no tienen porque devolver algo   | cada operacion devuelve un objeto construido |
   |----------------------------------+----------------------------------------------|
** Factory Method Vs. Strategy
*** Strategy
    - Es un patrón de comportamiento
    - El patrón *Strategy* define una familia de algoritmos que tienen mismo objetivo, pero con una implementación distinta
      (/Ej. escribir un log en consola/archivo, misma habilidad de dif. personajes de un juego, calcular un precio con o sin IVA, ordenar un conjunto de datos, .../)
    - La implementación de los algoritmos que define son independientes al contexto/cliente
    - El contexto/cliente NO saben cual estrategia usar, deben elegir alguna
*** Factory Method
    - Es un patrón creacional
    - Se crean objetos mediante una llamada al método de la clase factory, en vez de una llamada al *constructor*
    - NO se expone la lógica de creación del objeto al *cliente*
      (/Ej. creamos un auto del tipo lujoso, y el client sólo sabe que es eso, desconoce que se hizo para crearlo/)
** [TODO] Factory Vs. Abstract Factory
* Builder
** Ejemplo 1 - Builder Coche (clase abstracta)
 #+BEGIN_SRC plantuml :file diagramas-de-clases/builder-coche.png :exports results
   @startuml
   Title Patron Builder

   ' ================
   ' ==== CLASES ====
   ' ================

   abstract class BuilderCoche{
       #coche;
       +crearCoche();
       +getCoche();
       +{abstract} construirMotor();
       +{abstract} construirCarroceria()
       +construir()
   }

   class BuilderCocheModerno{
       +construirMotor();
       +construirCarroceria()
   }

   class BuilderCocheAntiguo{
       +construirMotor();
       +construirCarroceria()
   }

   class Coche{
       -carroceria
       -motor
       -velocidad
   }

   ' ================
   ' == RELACIONES ==
   ' ================

   BuilderCoche -r-> Coche
   BuilderCocheModerno -u-|> BuilderCoche
   BuilderCocheAntiguo -u-|> BuilderCoche

   ' ================
   ' ==== NOTAS =====
   ' ================

   note top of Coche
   ,**Product**
   ,* Se crean objetos de este tipo
   end note

   note top of BuilderCoche
   ,**Abstract Builder**
   ,* No se instancia, generaliza
   ,* Construye el objeto y lo devuelve
   ,* **construir()** ejecuta las configuraciones
   end note

   note as N
   ,**Concrete Builder**
   ,* Configuran el abstract builder
   ,* Implementan las configuraciones
   end note

   N .u. BuilderCocheAntiguo
   N .u. BuilderCocheModerno

   @enduml
 #+END_SRC

 #+RESULTS:
 [[file:diagramas-de-clases/builder-coche.png]]
** Ejemplo 2 - Builder Bebida (clase abstracta)
 #+BEGIN_SRC plantuml :file diagramas-de-clases/builder-bebida.png :exports results
   @startuml
   Title Patrón Builder

   ' ================
   ' ==== CLASES ====
   ' ================

   abstract class BebidaBuilder{
       #bebida
       +{abstract} void servir()
       +{abstract} void calentarAgua()
       +{abstract} void agregarExtras()
       +void preparar()
       +void crearBebida()
       +Bebida getBebida()
   }

   class CafeBuilder <<Concrete Builder>>{
       +void servir()
       +void calentarAgua()
       +void agregarExtras()
   }

   class TeBuilder  <<Concrete Builder>>{
       +void servir()
       +void calentarAgua()
       +void agregarExtras()
   }

   class Bebida <<Product>>{
       -int temperatura
       -String tipo
       -TamanioVaso tamanioVaso
   }

   ' ================
   ' == RELACIONES ==
   ' ================

   together {
   TeBuilder       -u-|> BebidaBuilder
   CafeBuilder     -u-|> BebidaBuilder
   BebidaBuilder   -r->  Bebida
   }

   ' ================
   ' ==== NOTAS =====
   ' ================

   note as N1
   ,**Abstract Builder**
   Declara los pasos de construcción
   que comparten los AbstractBuilder

   crearBebida(){
       bebida = new Bebida()
   }

   preparar(){
       crearBebida()
       calentarAgua()
       agregarExtra()
       servir()
   }
   end note

   note as N2
   @Override
   calentarAgua(){
       bebida.setTemperatura(60)
   }
   end note

   note as N3
   ,**Concrete Builder**
   ,* Implementa los pasos de construcción
   ,* Cada uno tiene su propia implementación

   @Override
   calentarAgua(){
       bebida.setTemperatura(90)
   }
   end note

   note as N4
   ,**Product**
   ,* Objeto que se va a construir
   end note

   N1 .r. BebidaBuilder
   N2 .u. CafeBuilder
   N3 .u. TeBuilder
   N4 .l. Bebida

   note bottom of N1
   Se pueden preparar las bebidas de la sig. manera:

   BebidaBuilder bebida = new CafeBuilder();
   bebida.preparar();
   Bebida cafe = bebida.getBebida();

   BebidaBuilder bebida = new TeBuilder();
   bebida.preparar();
   Bebida te = bebida.getBebida();
   end note

   @enduml
 #+END_SRC

 #+RESULTS:
 [[file:diagramas-de-clases/builder-bebida.png]]
** Ejemplo 3 - Builder Bebida (con interfaz)
   #+BEGIN_SRC plantuml :file diagramas-de-clases/builder-bebida-interfaz.png :exports results
     @startuml
     Title Patrón Builder (con interfáz)

     ' ================
     ' ==== CLASES ====
     ' ================

     class Cafeteria{
         +void cambiarBebida(BebidaBuilder builder)
         +void prepararBebida(BebidaBuilder builder)
     }

     interface BebidaBuilder{
         +void servir()
         +void calentarAgua()
         +void agregarExtras()
     }

     class CafeBuilder{
         -Cafe bebida
    
         +void servir()
         +void calentarAgua()
         +void agregarExtras()
         +Cafe getBebida()
     }

     class TeBuilder{
         -Te bebida
    
         +void servir()
         +void calentarAgua()
         +void agregarExtras()
         +Te getBebida()
     }

     class Cafe{
         -int temperatura
         -String tipo
         -TamanioVaso tamanioVaso
     }

     class Te{
         -int temperatura
         -String tipo
         -TamanioVaso tamanioVaso
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Cafeteria       -d-> BebidaBuilder

     TeBuilder       .u.|> BebidaBuilder
     CafeBuilder     .u.|> BebidaBuilder

     TeBuilder       -d-> Te
     CafeBuilder     -d-> Cafe

     ' ================
     ' ==== NOTAS =====
     ' ================

     note as N1
     ,**Abstract Builder**

     end note

     note as N2
     ,**Concrete Builder**
       TeBuilder(){ // constructor
         bebida = new Te()
       }

       @Override
       void calentarAgua(){    
         bebida.setTemperatura(80)
       }
  
       @Override
       void agregarExtras(){
         bebida.setTipo("dulce")
       }
     end note

     note as N3
     ,**Director**

     void prepararBebida(BebidaBuilder builder){
         cambiarBebida(bebidaBuilder)
    
         bebidaBuilder.calentarAgua()
         bebidaBuilder.agregarExtras()
         bebidaBuilder.servir()
     }
     end note

     N1 .l. BebidaBuilder
     N2 .r. TeBuilder
     N3 .r. Cafeteria

     note right of Te : **Product**

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/builder-bebida-interfaz.png]]
* Strategy
** Conceptos
   + Es un patrón de *comportamiento*
   + Predomina la *composición* por sobre la *herencia*
   + Permite intercambiar *comportamiento* en *tiempo de ejecución*
   + Encapsula comportamiento en cada *Strategy*
** Ejemplo 1 - Mortal Kombat
*** Problema
    Supongamos que queremos crear un juego de combate, y modelamos a los luchadores.
    Cada luchador tiene un movimiento de ataque (/darPuñetazo, darPatada, darSalto,.../)
    
    Algunos jugadores tienen un *comportamiento* diferente para ciertos ataques, como el darPuñetazo y darPatada. 
*** Solución por Herencia
     Podríamos modelar una clase ~Luchador~ con los 3 movimientos de ataque, y por *herencia*
     cada luchador sobreescriba el comportamiento. Pero que sucedería, si luego un jugador puede tener
     3 tipos de patadas diferentes? y otro puede lanzar 2 tipos de puñetazos diferentes?

     El problema con la herencia sería que tendriamos una clase ~Luchador~ con tantos *métodos* como tipos de ataque hayan.
     Entonces habría una clase con demasiado comportamiento.
*** Solución por Composición
    Ahora digamos que cambiamos la *herencia* por *composición* es decir, *delegamos comportamiento* en otras *clases*.
    En este caso la clase ~Luchador~ podría delegar aquellos movimientos de ataque que pueden variar.

    Por lo cual decidimos en la clase ~Luchador~ guardar una referencia de aquellas clases que *encapsulan el comportamiento*
    osea los movimientos de ataque especializados, y que implementan la misma *interfaz*.
    Algunos ataques podrían implementar la *interfaz* ~Patada~, y otros la *interfaz* ~Puñetazo~

    La ventaja de usar *composición* es que nos permite cambiar el *comportamiento* (movimientos de ataque)
    en *momento de ejecución* pudiendo un jugador tener en un instante dado una "patada voladora" y luego 
    una "patada rápida", ó que otro jugador disponga de un "puñetazo perforante" y luego pueda cambiarlo
    a un "puñetazo sangrante".
*** Cualidades de Diseño
*** Conceptos aplicados
**** Polimorfismo
     Aparece *polimorfismo* entre las clases ~PatadaRapida~, ~PatadaVoladora~ porque entienden el mismo mensaje ~darPatada()~
     aunque cada una tiene su propia *implementación*, su propia lógica, un comportamiento quizás similar ó diferente.
     Lo mismo ocurre con las clases ~PuñetazoSangrante~ y ~PuñetazoPerforante~.
*** Diagrama de clases
    #+BEGIN_SRC plantuml :file diagramas-de-clases/mortal-kombat-strategy.png :exports results
      @startuml
      Title Strategy - Mortal Kombat

      ' ================
      ' ==== CLASES ====
      ' ================

      rectangle "Context" as A{
          abstract class Luchador{
              -Patada patada
              -Puñetazo puñetazo
        
              +void darPatada()
              +void darPuñetazo()
              +{abstract} String getNombre()
              +void setPatada()
              +void setPuñetazo()
          }
    
          class Scorpion{
              +String getNombre()
              +void darPatada()
              +void darPuñetazo()
          }
    
          class Goro{
              +String getNombre()
              +void darPuñetazo()
          }
      }

      rectangle "Strategy #1\nComportamiento Encapsulado" #lightgreen{
          interface Patada{
              +void darPatada()
          }
    
          class PatadaRapida{
              +void darPatada()
          }
    
          class PatadaVoladora{
              +void darPatada()
          }
      }

      rectangle "Strategy #2\nComportamiento Encapsulado" #lightblue{
          interface Puñetazo{
              +void darPuñetazo()
          }
    
          class PuñetazoPerforante{
          +void darPuñetazo()
          }
    
          class PuñetazoSangrante{
              +void darPuñetazo()
          }
      }

      ' ================
      ' == RELACIONES ==
      ' ================

      Scorpion    .u.|> Luchador
      Goro        .u.|> Luchador

      PatadaVoladora      .u.|> Patada
      PatadaRapida        .u.|> Patada

      PuñetazoPerforante   .u.|> Puñetazo
      PuñetazoSangrante   .u.|> Puñetazo

      Luchador::patada    -l[thickness=2]-> Patada
      Luchador::puñetazo  -r[thickness=2]-> Puñetazo

      ' ================
      ' ==== NOTAS =====
      ' ================


      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:diagramas-de-clases/mortal-kombat-strategy.png]]
** Ejemplo 2 - Logger
   #+BEGIN_SRC plantuml :file diagramas-de-clases/logger-strategy.png :exports results
     @startuml
     Title Strategy - Logger

     ' ================
     ' ==== CLASES ====
     ' ================

     interface Logger{
         +void write(String mensaje)
     }

     class LoggerFichero{
         +void write(String mensaje)
     }

     class LoggerConsola{
         +void write(String mensaje)
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     LoggerFichero .u.|> Logger
     LoggerConsola .u.|> Logger

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of LoggerConsola
     class LoggerConsola implements Logger{
         @Override
         void write(String mensaje){
             System.out.println(mensaje);
         }
     }
     end note

     note top of LoggerFichero
     class LoggerFichero implements Logger{
         private String filePath;

         // constructor
         public LoggerFichero (String filePath){
             this.filePath = filePath;
         }

         @Override
         void write(String mensaje){
         // alguna lógica para escribir en ficheros..
         }
     }
     end note


     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/logger-strategy.png]]
** Ejemplo 3 - Juego FPS
   #+BEGIN_SRC plantuml :file diagramas-de-clases/juego-fps-strategy.png :exports results
     @startuml
     Title Strategy - Juego FPS

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Context" as A{
         abstract class Jugador{
             -String nombre
             -Tiro tipoTiro
             +void realizarTiro()
             +void setTiro(Tiro tipoTiro)
         }

         class Arquero{
             +void disparar()
         }

         class Soldado{
             +void disparar()
         }

     }

     rectangle "Strategy\nEncapsula comportamiento" as B{
         interface Tiro{
             +void realizarTiro()
         }

         class TiroPreciso{
             +void realizarTiro()
         }
         class TiroMortal{
             +void realizarTiro()
         }
         class TiroVeloz{
             +void realizarTiro()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Arquero -u-|> Jugador
     Soldado -u-|> Jugador

     TiroPreciso .u.|> Tiro
     TiroMortal .u.|> Tiro
     TiroVeloz .u.|> Tiro


     Jugador::tipoTiro -r-> Tiro : delega en

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of TiroPreciso
     @Override
     void realizarTiro(){
         System.out.println("100% de aciertos");
     }
     end note

     note bottom of TiroVeloz
     @Override
     void realizarTiro(){
         System.out.println("100 disparos consecutivos");
     }
     end note

     note top of Jugador
     void realizarTiro(){
         // notamos como delega en otra clase
         tipoTiro.realizarTiro();
     }

     void setTiro(Tiro tiro){
         // observamos que puede variar
         this.tipoTiro = tipoTiro;
     }
     end note

     note top of Tiro
     El patrón **Strategy**
     permite alternar entre los distintos algoritmos
     y cada algoritmo es independiente del resto
     (en este caso serían los tipos de tiros)
     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/juego-fps-strategy.png]]
* [TODO] Template method
  #+BEGIN_COMMENT
   https://refactoring.guru/es/design-patterns/template-method
  #+END_COMMENT
** Conceptos
   - Se basa en la *herencia*
   - Define una clase con un plantilla de operaciones que usarán las subclases (entienden los mismos mensajes)
   - La clase-padre reutiliza las operaciones en un método (no es necesario que estén en un orden específico)
** Ejemplo 1 - Validar Cuenta Web
   #+BEGIN_SRC plantuml :file diagramas-de-clases/validar-cuenta-web-template.png :exports results
     @startuml
     Title Template Method - Aplicación Web

     ' ================
     ' ==== CLASES ====
     ' ================

     abstract class AccesoWeb{
         -String usuario
         -String clave
         +void validarCuenta()
         +{abstract} void obtenerDatos()
         +{abstract} boolean validarPermisos()
         +{abstract} void mostrarPagina()
     }

     class AccesoPremium{
         +void obtenerDatos()
         +boolean validarPermisos()
         +void mostrarPagina()
     }

     class AccesoGratuito{
         +void obtenerDatos()
         +boolean validarPermisos()
         +void mostrarPagina()
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     AccesoPremium   -u-|> AccesoWeb
     AccesoGratuito  -u-|> AccesoWeb

     ' ================
     ' ==== NOTAS =====
     ' ================

     note left of AccesoWeb
     abstract void obtenerDatos();
     abstract boolean validarPermisos();
     abstract void mostrarPagina();

     // el **final** evita que una subclase la sobrescriba
     ,**final** void validarCuenta(){
         obtenerDatos();
         if(validarPermisos() == true)
             mostrarPagina();
         else
             throw new SinPermisosException();
     }
     end note

     note right of AccesoWeb
     El **método plantilla** se basa en **herencia**

     Cuando multiples clases tienen igual comportamiento/lógica
     usamos la herencia evitando tener la misma lógica
     repartida en varias clases.

     Se tiene un método que reutiliza las operaciones de las 
     clases hijas, en este caso será **validarCuenta()**
     end note

     note right of AccesoPremium
     // lógica específica para usuarios premium
     @Override
     void obtenerDatos(){
         // de una tabla clientesPremium de una base de datos
     }
     @Override
     boolean validarPermisos(){
         // debe cumplir con ciertos permisos para ser Premium
     }
     @Override
     void mostrarPagina(){
         // muestra una sección sólo para usuarios premium
     }
     end note

     note as N1
     Cada clase hará su implementación de cada operación
     sobreescribiendo cada método, ó reutilizando la lógica
     que tuviese la super clase
     end note

     N1 .u. AccesoPremium
     N1 .u. AccesoGratuito
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/validar-cuenta-web-template.png]]
** Ejemplo 2 - Juego de Cartas
   #+BEGIN_SRC plantuml :file diagramas-de-clases/juego-de-cartas-template.png :exports results
     @startuml
     Title Template Method - Juego de Cartas

     ' ================
     ' ==== CLASES ====
     ' ================

     abstract class JuegoCartas{
         +{abstract} void inicializar()
         +{abstract} void iniciar()
         +{abstract} void finalizar()
         +void jugar()
     }

     class Truco{
         +{abstract} void inicializar()
         +{abstract} void iniciar()
         +{abstract} void finalizar()
     }

     class Poker{
         +{abstract} void inicializar()
         +{abstract} void iniciar()
         +{abstract} void finalizar()
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Truco -u-|> JuegoCartas
     Poker -u-|> JuegoCartas

     ' ================
     ' ==== NOTAS =====
     ' ================

     note top of Poker
     @Override
     void inicializar(){
         // reparte X cartas de un tipo
     }

     @Override
     void iniciar(){
         System.out.println("Bienvenido al Poker");
     }

     @Override
     void finalizar(){
         // cuando se llegó a X puntaje
     }
     end note

     note top of Truco
     @Override
     void inicializar(){
         // reparte Y cartas de otro tipo
     }

     @Override
     void iniciar(){
         System.out.println("Bienvenido al truco");
     }

     @Override
     void finalizar(){
         // cuando se llegó a Y puntaje
     }
     end note


     note top of JuegoCartas
     abstract void inicializar();
     abstract void iniciar();
     abstract void finalizar();

     ,**final** void jugar(){
         inicializar();
         iniciar();
         finalizar();
     }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/juego-de-cartas-template.png]]
* [DONE] Factory Method
CLOSED: [2021-12-08 mié 17:21]
** Conceptos
   - Como su nombre lo dice, _se invoca a una operación (factory method) para crear objetos_
   - El *factory method* devuelve distintas instancias de Clases (/Concrete Products/) según cual pidamos por parámetro, pero todas implementan la interfáz de *Product*
   - Cada *Concrete Product* tiene su propia implementación de la interfaz *Product*
   - La interfaz *Creator* (/ó super clase abstracta/) delega la creación de los objetos en las subclases *Concrete Creator* que la implementan (/ó que extiendan si fuese superclase abstracta/)
   - Los *Concrete Creator* tienen la lógica para decidir que clase instanciar (/concrete product/) ó.. pueden reescribir el comportamiento por defecto, si se usara Herencia
     (/Ej. reciben un tipo 'PizzaClasica' por parámetro, y una decide crear una instancia de PizzaVegana pero podría redefinirlo para crear una instancia de la clase PizzaNapolitana/)

   #+BEGIN_QUOTE
   Se conoce por *Creator/Factory* al que tiene la operación de crear los objetos (factory method)
   
   Si definimos al *Creator* como una Interfaz, entonces dejamos decidir a las clases que la implementan,
   definir la lógica de que clase instanciar

   Si definimos al *Creator* como clase abstracta, entonces ésta puede definir por defecto que instancias de clases se deben crear,
   y las subclases *Concrete creator* pueden o no sobreescribir su comportamiento, devolviendo otras instancias de clases.
   
   También podríamos elegir que fuese clase abstracta, si ésta tiene un estado (Ej. nombre)
   #+END_QUOTE

   #+BEGIN_qUOTE
   Por ejemplo si el *Creator* es una "Fábrica de Pizzas" ésta podría ser una clase abstracta,
   y podría tener como *Concrete Creators* una "Fábrica de Pizzas Veganas" y una "Fábrica de Pizzas Tradicional".
   
   Entonces las subclases del Creator ante un parámetro "tipo sabrosa" ó "tipo clásica" podrían devolver una pizza diferente,
   porque la "fábrica de pizzas veganas" tendería a crear una "pizza con palta" como sabrosa, y una "pizza de hongos" como clásica
   mientras que "fabrica de pizzas tradicional" puede crear una "pizza napolitana" como clásica, y una "pizza con extra queso" como sabrosa

   ambos *Concrete Creator* crean un objeto con la misma Interfaz del producto que es "Pizza"
   #+END_QUOTE
** Cualidades de Diseño
   - *Mayor extensibilidad* para agregar características (nuevos tipos de productos) con bajo impacto
   - *Bajo acoplamiento* entre el Cliente y la creación de objetos
** Ejemplo 1 - Fabrica de Juguetes Marvel
   #+BEGIN_SRC plantuml :file diagramas-de-clases/jueguetes-marvel-factory.png :exports results
     @startuml
     Title Patrón Factory Method (Fábrica de Jugetes Marvel)

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Factory Method #2"{
         enum TipoEspecie{
             CYBORG
             HUMANO
         }

         interface ILaboratorio<<Creator>>{
             +Especie crearEspecie(TipoEspecie tipo)
         }

         class Laboratorio<<Concrete Creator>>{
             +Especie crearEspecie(TipoEspecie tipo)
         }

         abstract class Especie<<Product>>{
             -Number velocidad
             +String hablar()
             +void correr()
             +String getNombre()
         }

         class Humano<<Concrete Product>>{
             +String hablar()
             +void correr()
             +String getNombre()
         }

         class Cyborg<<Concrete Product>>{
             +String hablar()
             +void correr()
             +String getNombre()
         }
     }

     package "Factory Method #1"{
         interface IFabricaJuguetes<<Creator>>{
             +Jugete crearJuguete(String tipo)
         }

         class FabricaDisney<<Concrete Creator>>{
             +Jugete crearJuguete(String tipo)
         }

         class FabricaLego<<Concrete Creator>>{
             +Jugete crearJuguete(String tipo)
         }

         interface Juguete<<Product>>{
             +String hablar()
             +void caminar()
             +String getNombre()
         }

         class Thanos<<Concrete Product>>{
             +String hablar()
             +void caminar()
             +String getNombre()
         }

         class Wolverine<<Concrete Product>>{
             +String hablar()
             +void caminar()
             +String getNombre()
         }

         class NullJuguete{
             +String hablar()
             +void caminar()
             +String getNombre()
         }
     }
     ' ================
     ' == RELACIONES ==
     ' ================

     Thanos      .up.|> Juguete
     Wolverine   .up.|> Juguete
     NullJuguete    .left.|> Juguete


     IFabricaJuguetes    .right.> Juguete : crear

     FabricaDisney     .up.|> IFabricaJuguetes
     FabricaLego     .up.|> IFabricaJuguetes

     Laboratorio    .up.|> ILaboratorio
     ILaboratorio    .right.> Especie
     Humano          -up-|> Especie
     Cyborg          -up-|> Especie

     ILaboratorio    .left.> TipoEspecie
     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/jueguetes-marvel-factory.png]]

** Ejemplo 2 - Computadoras Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/computadoas-factory.png :exports results
     @startuml
     Title Patrón Method Factory (Computadoras)

     ' ================
     ' ==== CLASES ====
     ' ================

     class ComputadoraFactory{
         +{static} Computadora getCompu(String tipo, int ram, int cpu, int hdd)
     }

     abstract class Computadora{
         -{abstract} String ram
         -{abstract} String cpu
         -{abstract} String hdd
     }

     class PC{
         -String ram
         -String cpu
         -String hdd
     }

     class Notebook{
         -String ram
         -String cpu
         -String hdd
     }

     class NullCompu{
         -String ram
         -String cpu
         -String hdd
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     PC          -up-|> Computadora
     Notebook    -up-|> Computadora
     NullCompu    -up-|> Computadora

     ComputadoraFactory .right.> Computadora

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of ComputadoraFactory
       public **static** Computadora getCompu(String tipo, String ram, String cpu, String hdd){
         if("notebook".equalsIgnoreCase(tipo)){
           return new Notebook(ram, cpu, hdd);
         }
         else if("pc".equalsIgnoreCase(tipo)){
           return new PC(ram, cpu, hdd);
         }   
    
         ,**return new NullComputadora();**
       }

     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/computadoas-factory.png]]
** Ejemplo 3 - Transportes Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/transportes-factory.png :exports results
     @startuml
     Title Patrón Method Factory (Transportes)

     ' ================
     ' ==== CLASES ====
     ' ================

     interface ITransporteFactory{
         +Transporte getTransporte(String tipo)
     }

     class TransporteFactory{
     +Transporte getTransporte(String tipo)
     }


     interface Transporte{
         +void reparar()
         +void conducir()
         +double costoMantenimiento()
     }

     class Avion{
         +void reparar()
         +void conducir()
         +double costoMantenimiento()
     }

     class Tren{
         +void reparar()
         +void conducir()
         +double costoMantenimiento()
     }

     class Submarino{
         +void reparar()
         +void conducir()
         +double costoMantenimiento()
     }

     class NullTransporte{
         +void reparar()
         +void conducir()
         +double costoMantenimiento()
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Avion       .up.|> Transporte
     Tren        .up.|> Transporte
     Submarino   .up.|> Transporte
     NullTransporte   .left.|> Transporte


     TransporteFactory   .up.|> ITransporteFactory
     ITransporteFactory .right.> Transporte

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of TransporteFactory
       @Override
       public Transporte getTransporte(String tipo){
         if("avion".equalsIgnoreCase(tipo)){
           return new Avion();
         }
         else if("tren".equalsIgnoreCase(tipo)){
           return new Tren();
         }
         else if("submarino".equalsIgnoreCase(tipo)){
           return new Submarino();
         }

         ,**return new NullTransporte();**
       }
     end note

     note bottom of Tren
       ,**// cada transporte tendrá su propia lógica**
       ,**// con una implementación similar o diferente**
       @Override
       public void reparar(){
         System.out.println("Reparando ruedas");
       }

       @Override
       public void conducir(){
         System.out.println("Calentando motores");
       }

       @Override
       public double costoMantenimiento(){
         return 250*3+15;
       }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/transportes-factory.png]]

** Ejemplo 4 - Archivos Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/archivo-factory.png :exports results
     @startuml
     Title Patrón Factory-Method

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Product - Concrete Product" as A{
         interface Documento{
             #String nombre
             +void abrir()
             +void cerrar()
             +void guardar()
         }

         class DocumentoPDF
         class DocumentoWord
     }


     rectangle "Factory - Concrete Factory" as B{
         interface DocumentoFactory{
             +Documento getDoc(String tipo, String nom)
         }

         class WindowsFactory{
            +Documento getDoc(String tipo, String nom)
         }

         class LinuxFactory{
             +Documento getDoc(String tipo, String nom)
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     DocumentoPDF .u.|> Documento
     DocumentoWord .u.|> Documento

     WindowsFactory  .u.|> DocumentoFactory
     LinuxFactory    .u.|> DocumentoFactory

     DocumentoFactory  .r.> Documento

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of DocumentoPDF
       public DocumentoPDF(String nombre){
         this.nombre = nombre;
    
         System.out.println("Cargando paquetes PDF..");
       }
  
       @Override
       public void abrir(){
         System.out.println("Abriendo archivo PDF..");
       }
  
       @Override
       public void cerrar(){
         System.out.println("Cerrando archivo PDF..");
       }
  
       @Override
       public void guardar(){
         System.out.println("Guardadno archivo PDF..");
       }
     end note

     note bottom of WindowsFactory
       @Override
       public Documento getDoc(String tipo, String nombreArchivo){
         if("pdf".equalsIgnoreCase(tipo)){
           System.out.println("Cargando bibliotecas de windows");
           return new DocumentoPDF(nombreArchivo);
         }
         else if("word".equalsIgnoreCase(tipo)){
           System.out.println("Cargando bibliotecas de windows");
           return new DocumentoWord(nombreArchivo);
         }
    
         ,**throw new IllegalArgumentException("No existe este tipo de documento");**
       }
     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/archivo-factory.png]]
** Ejemplo 5 - Videojuego Personajes Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/personaje-factory.png :exports results
     @startuml
     Title Patrón Factory-Method (Personajes de Videojuegos)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Factory - Concrete Factories" as A{
         note left of PersonajeFactory
         Usaremos condicionales if/else ó un switch
         para saber que tipo de instancia 
         retornaremos (Barbaro ó Arquero)
    
         Si no se cumple ninguna podemos lanzar una
         excepción del tipo **IllegalArgumentException**
         ó usar el **patrón nullObject**
         end note

         abstract class PersonajeFactory{
             -String nombre
             +Personaje crearPersonaje(String tipo, String nombre)
         }
    
         class RandomFactory{
             +Personaje crearPersonaje(String tipo, String nombre)
         }
         class PoderososFactory{
             +Personaje crearPersonaje(String tipo, String nombre)
         }
     }

     rectangle "Product - Concrete Product" as B{
         interface Personaje{
             +void correr()
             +void saltar()
         }
    
         class Arquero{
             +void correr()
             +void saltar()
         }
    
         class Barbaro{
             +void correr()
             +void saltar()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     '
     Arquero .u.|> Personaje
     Barbaro .u.|> Personaje

     RandomFactory       -u-|> PersonajeFactory
     PoderososFactory   -u-|> PersonajeFactory

     PersonajeFactory    .r.>  Personaje : usa

     ' ================
     ' ==== NOTAS =====
     ' ================

     note as N1
     ,**Concrete Factory**

     crearPersonaje(){
     // un algoritmo para
     // elegir un personaje random
     }
     end note

     note as N2
     ,**Concrete Factory**

     crearPersonaje(){
     // otro algoritmo para
     // elegir los más poderosos
     }
     end note

     note as N3
     Estos tipos de personajes tienen
     su lógica/implementación propia 
     sobre los mensajes **correr()** y 
     ,**saltar()** según diferentes factores
     del juego (Ej. terreno, ambiente, etc..)
     end note

     N1 .u. RandomFactory
     N2 .u. PoderososFactory

     N3 .u. Arquero
     N3 .u. Barbaro
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/personaje-factory.png]]

** Ejemplo 6 - Agencia Vehiculos Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/agencia-vehiculos-factory.png :exports results
     @startuml
     Title Patrón Factory-Method (Agencia de vehículos)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Product - Concrete Product" as A{
         abstract class Vehiculo{
             #int cantRuedas
             +void conducir()
         }

         class Bicicleta{
             +void conducir()
         }

         class Auto{
             +void conducir()
         }
     }

     rectangle "Factory - Concrete Factories" as B{
         interface AgenciaVehiculoFactory{
             +Vehiculo crearVehiculo(String tipo)
         }

         class LineaDeportivaFactory{
             +Vehiculo crearVehiculo(String tipo)
         }

         class LineaFamiliarFactory{
             +Vehiculo crearVehiculo(String tipo)
         }
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     Bicicleta   -u-|> Vehiculo
     Auto        -u-|> Vehiculo

     AgenciaVehiculoFactory .r.> Vehiculo

     LineaDeportivaFactory .u.|> AgenciaVehiculoFactory
     LineaFamiliarFactory .u.|> AgenciaVehiculoFactory

     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/agencia-vehiculos-factory.png]]
** Ejemplo 7 - Servicio Mensajes Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/servicio-mensajes-factory.png :exports results
     @startuml
     Title Patrón Factory-Method (Servicio de Mensajeria)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Product - Concrete Products" as A{
         interface Mensaje{
             +void enviar()
         }

         class MensajeDeVoz{
             -String destinatario
             -int duracion
             -int calidad
             +void enviar()
         }
         class MensajeSMS{
             -String destinatario
             -String texto
             +void enviar()
         }
     }

     rectangle "Factory - Concrete Factories" as B{
         abstract class ServicioMensajeFactory{
             +Mensaje crearMensaje(String tipo)
         }

         class WhatsappFactory{
             +Mensaje crearMensaje(String tipo)
         }

         class TelegramFactory{
             +Mensaje crearMensaje(String tipo)
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     MensajeDeVoz .u.|> Mensaje
     MensajeSMS .u.|> Mensaje

     ServicioMensajeFactory -r-> Mensaje

     WhatsappFactory -u-|> ServicioMensajeFactory
     TelegramFactory -u-|> ServicioMensajeFactory

     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/servicio-mensajes-factory.png]]
** [TODO] Ejemplo 8 - Multimedia Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/multimedia-factory.png :exports results
     @startuml
     Title Patrón Factory-Method

     ' ================
     ' ==== CLASES ====
     ' ================

     abstract class ArchivoFactory{
         +ArchivoMultimedia crearArchivo()
     }

     class FullHDFactory{
         +ArchivoMultimedia crearArchivo()
     }

     class LowFactory{
         +ArchivoMultimedia crearArchivo()
     }

     interface ArchivoMultimedia{
         +void reproducir()
     }

     class ArchivoVideo
     class ArchivoAudio

     ' ================
     ' == RELACIONES ==
     ' ================

     ArchivoVideo .u.|> ArchivoMultimedia
     ArchivoAudio .u.|> ArchivoMultimedia

     FullHDFactory    -u-|> ArchivoFactory
     LowFactory       -u-|> ArchivoFactory

     ArchivoFactory .r.> ArchivoMultimedia

     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
   #+END_SRC
* Abstract Factory
** Conceptos
   - Proporciona una interfaz para crear _familias de objetos relacionados_
   - Se requiere un *getter* en la *fabrica abstracta* por cada *producto abstracto* 
** Ejemplo 1 - Panaderia Abstract Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/panaderia-abstract-factory.png :exports results
     @startuml
     Title Patrón Abstract Factory

     ' ================
     ' ==== CLASES ====
     ' ================


     rectangle "Product - Concrete Product" as A #lightgreen{
         interface Sanwich{
             +void calentar()
             +void agregarCondimentos()
         }
    
         class SanwichMilanesa
         class SanwichVegetariano
     }


     rectangle "Product - Concrete Product" as B #lightblue{
         interface Empanada{
             +void cocinar()
             +void hacerRepulge()
         }
    
         class EmpanadaCarne
         class EmpanadaVerdura
     }

     rectangle "Concrete Factories - Abstract Factory" as c{
     abstract class PanaderiaFactory{
         -Factory factory
         +Empanada crearEmpanada()
         +Pizza crearPizza()
     }

     class PanaderiaBarrialFactory{
         +Empanada crearEmpanada()
         +Pizza crearPizza()
     }

     class PanaderiaGourmetFactory{
         +Empanada crearEmpanada()
         +Pizza crearPizza()
     }
     }
     ' ================
     ' == RELACIONES ==
     ' ================

     PanaderiaBarrialFactory -u-|> PanaderiaFactory
     PanaderiaGourmetFactory -u-|> PanaderiaFactory

     PanaderiaBarrialFactory .[#blue,dashed,thickness=2]d.> EmpanadaCarne
     PanaderiaGourmetFactory .[#blue,dashed,thickness=2]r.> EmpanadaVerdura

     PanaderiaBarrialFactory .[#green,dashed,thickness=2]d.> SanwichMilanesa
     PanaderiaGourmetFactory .[#green,dashed,thickness=2]r.> SanwichVegetariano

     EmpanadaVerdura     .u.|> Empanada
     EmpanadaCarne       .u.|> Empanada

     SanwichVegetariano  .u.|> Sanwich
     SanwichMilanesa     .U.|> Sanwich


     ' ================
     ' ==== NOTAS =====
     ' ================


     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/panaderia-abstract-factory.png]]
** Ejemplo 2 - GUI Abstract Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/gui-abstract-factory.png :exports results
     @startuml
     Title Patrón Abstract Factory - GUI Windows/Linux

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Product #1 - Concrete Products\nFamilia de Botones"{
         interface Boton{
             +void cerrarVentana()
             +void reproducirSonido()
         }

         class WinBoton{
             +void cerrarVentana()
             +void reproducirSonido()
         }
         class LinuxBoton{
             +void cerrarVentana()
             +void reproducirSonido()
         }
     }

     rectangle "Product #2 - Concrete Products\nFamilia de Checkboxes"{
         interface Checkbox{
             +void click()
         }

         class WinCheckbox{
             +void click()
         }
         class LinuxCheckbox{
             +void click()
         }
     }

     rectangle "Abstract Factory - Concrete Factories"{
         abstract class GUIFactory{
             -Factory GUIFactory
             +{abstract} Boton crearBoton()
             +{abstract} Checkbox crearCheckbox()
         }

         class GUIWinFactory{
             +Boton crearBoton()
             +Checkbox crearCheckbox()
         }

         class GUILinuxFactory{
             +Boton crearBoton()
             +Checkbox crearCheckbox()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     GUIWinFactory      -u-|> GUIFactory
     GUILinuxFactory    -u-|> GUIFactory

     WinBoton        .u.|> Boton
     LinuxBoton      .u.|> Boton

     WinCheckbox     .u.|> Checkbox
     LinuxCheckbox   .u.|> Checkbox

     GUIWinFactory      .r.> WinCheckbox
     GUIWinFactory      .r.> WinBoton

     GUILinuxFactory    .d.> LinuxCheckbox
     GUILinuxFactory    .d.> LinuxBoton

     ' ================
     ' ==== NOTAS =====
     ' ================


     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/gui-abstract-factory.png]]
** Ejemplo 3 - Jugeteria Abstract Factory (con función genérica)
   #+BEGIN_SRC plantuml :file diagramas-de-clases/jugeteria-abstract-factory.png :exports results
     @startuml
     Title Patrón Abstract Factory - Jugeteria

     ' ================
     ' ==== CLASES ====
     ' ================

     class Programa{
         JugeteriaFactory getFactory(String factory)
     }

     rectangle "Product - Concrete Products \nFamilia de Animales" as Animales{
         interface Animal{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }
         class Leon{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }

         class Puma{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }

         class Tigre{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }
     }

     rectangle "Product - Concrete Products \nFamilia de Colores" as Colores{
         interface Color{
             +String getColor()
         }
         class Blanco{
             +String getColor()
         }

         class Naranja{
             +String getColor()
         }
     }


     class AnimalFactory{
         +Animal crearAnimal(String tipo)
     }

     class ColorFactory{
         +Color crearColor(String tipo)
     }

     interface JugeteriaFactory{
         +T crear(String factory)
     }
     ' ================
     ' == RELACIONES ==
     ' ================

     Leon    .u.|> Animal
     Tigre   .u.|> Animal
     Puma    .u.|> Animal

     Blanco      .u.|> Color
     Naranja     .u.|> Color

     AnimalFactory   .u.|> JugeteriaFactory
     ColorFactory    .u.|> JugeteriaFactory

     AnimalFactory   .d.> Animal
     ColorFactory    .d.> Color

     Programa .l.> JugeteriaFactory

     ' ================
     ' ==== NOTAS =====
     ' ================


     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/jugeteria-abstract-factory.png]]
** Ejemplo 4 - Laboratorio Abstract Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/laboratorio2-abstract-factory.png :exports results
     @startuml
     Title Patrón Abstract Factory - Animales

     ' ================
     ' ==== CLASES ====
     ' ================

     class Programa{
         LaboratorioFactory getFactory(String factory)
     }

     rectangle "Product - Concrete Products \nFamilia de Animales" as Animales{
         interface Animal{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }
         class Leon{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }
    
         class Puma{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }
    
         class Tigre{
             +String getTipo()    
             +void caminar()
             +void gruñir()
         }
     }

     rectangle "Product - Concrete Products \nFamilia de Colores" as Colores{
         interface Color{
             +String getColor()
         }
         class Blanco{
             +String getColor()
         }
    
         class Naranja{
             +String getColor()
         }
     }


     class AnimalFactory{
         +Animal crearAnimal(String tipo)
         +Color crearColor(String tipo)
     }

     class ColorFactory{
         +Color crearColor(String tipo)
         +Animal crearAnimal(String tipo)
     }

     interface LaboratorioFactory{
         Animal crearAnimal(String animal)
         Color crearColor(String color)
     }
     ' ================
     ' == RELACIONES ==
     ' ================

     Leon    .u.|> Animal
     Tigre   .u.|> Animal
     Puma    .u.|> Animal

     Blanco      .u.|> Color
     Naranja     .u.|> Color

     AnimalFactory   .u.|> LaboratorioFactory
     ColorFactory    .u.|> LaboratorioFactory

     AnimalFactory   .d.> Animal
     ColorFactory    .d.> Color

     Programa .l.> LaboratorioFactory

     ' ================
     ' ==== NOTAS =====
     ' ================

     note as N1
     Si usaramos una función genérica
     como **T crear(String tipo)**
     no necesitaríamos agregar una función
     por cada factoria concreta
     end note

     N1 .r. LaboratorioFactory
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/laboratorio2-abstract-factory.png]]
** Ejemplo 5 - Prestamos Bancarios Abstract Factory
   #+BEGIN_SRC plantuml :file diagramas-de-clases/prestamos-abstract-factory.png :exports results
     @startuml
     Title Patrón Abstract Factory - Prestamos Bancarios

     ' ================
     ' ==== CLASES ====
     ' ================

     cloud "Client"{
         class Aplicacion{
             +{static} SistemaFactory getFactory(String Factory)
         }
     }

     rectangle "Product - Concrete Products \nFamilia de Bancos" as A{
         interface Banco{
             +String getNombre()
         }
    
         class BancoCiudad{
             -String nombre
             +String getNombre()
         }
    
         class BancoProvincia{
             -String nombre
             +String getNombre()
         }
     }

     rectangle "Product - Concrete Products \nFamilia de Prestamos" as B{
         abstract class Prestamo{
             -int valor
             -int intereses
             +{abstract} void calcularIntereses()
             +void calcularPestamo()
         }
    
         class PrestamoEstudiantil{
             +void calcularIntereses()
         }
    
         class PrestamoPYME{
             +void calcularIntereses()
         }
    
         class PrestamoFamiliar{
             +void calcularIntereses()
         }
     }

     rectangle "Abstract Factory - Concrete Factories" as C{
         class BancoFactory{
             +Banco crearBanco()
         }
    
         class PrestamoFactory{
             +Prestamo crearPrestamo()
         }
    
         abstract class SistemaFactory{
             +Prestamo crearPrestamo()
             +Banco crearBanco()
         }
     }
     ' ================
     ' == RELACIONES ==
     ' ================

     BancoCiudad     .u.|> Banco
     BancoProvincia  .u.|> Banco


     PrestamoEstudiantil -u-|> Prestamo
     PrestamoPYME        -u-|> Prestamo
     PrestamoFamiliar    -u-|> Prestamo

     BancoFactory    -u-|> SistemaFactory
     PrestamoFactory -u-|> SistemaFactory

     PrestamoFactory .d.> Prestamo
     BancoFactory    .d.> Banco

     Aplicacion .l.>  SistemaFactory

     ' ================
     ' ==== NOTAS =====
     ' ================


     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/prestamos-abstract-factory.png]]

* [DOING] Command
** Links
   1. https://www.programmergirl.com/command-design-pattern-java/
** Conceptos
   - Permite *desacoplar* el objeto que invoca (Invoker) a la operación asociada (),
     mediante un objeto (command)
   - Se intenta *desacoplar* la vista (GUI) del modelo de negocios (los receptores)
   - El *invocador* sería como la GUI (menu de opciones, boton, ...)
** Objetos
*** Invocador
    - Es el que invoca y gestiona las ordenes/comandos concretos
    - Se puede repesentar en una GUI como un "menú de opciones, un menú desplegable, ..."
*** Command
    - Es el nexo ó puente entre el *invocador* y el *receptor*
      (desacoplando la GUI que sería el invocador del modelo de negocio que seria el receptor o receptores)
    - Es la interfaz que tienen en común el resto de las ordenes (concreteCommands)
    - Se puede interpretar como los "botones de un control remoto, jostick, .."
*** Receptor
    - Es el objeto que recibe las ordenes y realiza una acción concreta
    - Se puede interpretar como "un dispositivo electrónico, un procesador de texto, ..."
** Ejemplos
*** Ejemplo 1 - Videojuegos
   Si lo llevamos a los videojuegos, podriamos decir que..
   - El *invocador* es el "jostick" que gestiona todos los comandos que se mandarán al dispositivo
   - El *command* es la interfaz que deben tener todos los botones de la jostick
   - Los *concrete commands* serían cada boton que tiene una funcionalidad
   - El *receptor* es el dispositivo playstation, gameboy, nintendo, etc...
*** Ejemplo 2 - Dispositivos electrónicos
    Si tenemos varios dispositivos electrónicos como "televisor, equipo de musica, .."
    y tenemos sólo un "control remoto universal" que funciona para encender/apagar cada uno
    - El *invocador* sería el "control remoto" el que gestiona los comandos
    - El *command* sería la interfáz que tienen en común los dos botones de encendido/apagado
      del "control remoto"
    - Los *concrete commands* son el botón de encendido/apagado, y _tendremos que adaptarlos_
      según el dispositivo receptor, porque uno puede entender ~on~ otro ~encender~ y así..
    - Los *receptores* serían el "televisor, el equipo de música, .." quienes tienen su propia
      implementación de como encender/apagar (nos desentendemos de eso, nosotros solo le
      decimos queremos que te enciendas, queremos que te apages, y punto)

    *Importante:*
    Los *concrete commands*  _tendremos que adaptarlos_ según el *receptor*
    ya que cada receptor la accion asociada al comando puede variar,
    porque cada receptor tiene su propia implementación para una acción.
*** Ejemplo 3 - Software Office
    Si tenemos el paquete de office (word, excel, access, ...) todos tienen algo en común,
    reciclan la interfaz y la adaptan a la aplicación
    En este caso cada aplicación sería un *receptor*
*** Ejemplo 4 - Aplicacion para dispositivos Android y Iphone
    Si queremos armar una aplicación que funcione para ambos dispositivos,
    tendremos que adaptar los *concrete commads* según el dispositivo (android ó un ihpone).
    
    Porque no es lo mismo la acción de guardar cambios de un archivo para ambos,
    como tampoco el sacar una foto, etc..

    Por lo cual, si tenemos nuestro modelo *command* con solo adaptar los *concrete commands*
    podemos llevarlo a distintos plataformas
    (/Ej. linux/windows ó android/iphone, nintendo/playstation, .../)
** Ejemplo 1 - Editor de Texto v1
   #+BEGIN_SRC plantuml :file diagramas-de-clases/procesador-de-texto-command.png :exports results
     @startuml
     Title Patrón Command (Editor de Texto)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Command - Concrete Commands"{
         interface Command{
             +void ejecutar()
         }

         class CommandAbrir <<Concrete Command>>{
             -EditorTexto editor

             +void ejecutar()
         }
    
         class CommandCerrar <<Concrete Command>>{
             -EditorTexto editor

             +void ejecutar()
         }
    
         class CommandGuardar <<Concrete Command>>{
             -EditorTexto editor

             +void ejecutar()
         }
     }

     ''''''''''''''''''''''''''''''''''''''

     class EditorTexto <<Receptor>>{
         +void accionAbrir()
         +void accionCerrar()
         +void accionGuardar()
     }

     class MenuOpciones <<Invocador>>{
         -Command commandAbrir
         -Command commandCerrar
         -Command commandGuardar

         +void clickBotonAbrir()
         +void clickBotonCerrar()
         +void clickBotonGuardar()
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     CommandAbrir     .u.|> Command
     CommandCerrar    .u.|> Command
     CommandGuardar   .u.|> Command

     MenuOpciones     -l-> Command

     CommandAbrir     -d-> EditorTexto
     CommandCerrar    -d-> EditorTexto
     CommandGuardar   -d-> EditorTexto

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of CommandGuardar
       // constructor
       public CommandGuardar(EditorTexto editor){
         this.editor = editor;
       }

       @Override
       public void ejecutar(){
         editor.accionGuardar();
       }
     end note

     note bottom of MenuOpciones
         // constructor
         // agregar como parámetros el de cerrar y guardar
       public MenuOpciones(Command abrir, ...){
         this.commandAbrir = abrir;  
         this.commandCerrar = cerrar;  
         this.commandGuardar = guardar;  
       }
  
       void clickBotonAbrir(){
         commandAbrir.ejecutar();
       }

       // repetir para guardar y cerrar
     end note

     note bottom of EditorTexto
       void accionAbrir(){
         System.out.println("Abriendo Editor..");
       }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/procesador-de-texto-command.png]]
** Ejemplo 2 - Editor de Texto v2 (Con historial)
   #+BEGIN_SRC plantuml :file diagramas-de-clases/procesador-de-textov2-command.png :exports results
     @startuml
     Title Patrón Command (Editor de Texto v2)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Command - Concrete Commands"{
         interface Command{
             +String ejecutar()
         }

         class CommandAbrir <<Concrete Command>>{
             -EditorTexto nombreArchivo

             +String ejecutar()
         }

         class CommandCerrar <<Concrete Command>>{
             -EditorTexto nombreArchivo

             +String ejecutar()
         }

         class CommandGuardar <<Concrete Command>>{
             -EditorTexto nombreArchivo

             +String ejecutar()
         }
     }

     ''''''''''''''''''''''''''''''''''''''

     class EditorTexto <<Receptor>>{
         -String mensaje
         -String nombreArchivo
         +String accionAbrir()
         +String accionCerrar()
         +String accionGuardar()
     }

     class MenuOpciones <<Invocador>>{
         -Command command
         -List<Command> historialAcciones

         +String clickBoton(Command concreteCommand)
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     CommandAbrir     .u.|> Command
     CommandCerrar    .u.|> Command
     CommandGuardar   .u.|> Command

     MenuOpciones     -l-> Command

     CommandAbrir     -d-> EditorTexto
     CommandCerrar    -d-> EditorTexto
     CommandGuardar   -d-> EditorTexto

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of CommandGuardar
       // constructor
       public CommandGuardar(EditorTexto nombreArchivo){
         this.nombreArchivo = nombreArchivo;
       }
  
       @Override
       public String ejecutar(){
         return nombreArchivo.accionGuardar();
       }
     end note

     note bottom of MenuOpciones
       private final List<Command> historialAcciones = new ArrayList<>();

       public String clickBoton(Command concreteCommand){
         historialAcciones.add(concreteCommand);
    
         return concreteCommand.ejecutar();
       }
     end note

     note bottom of EditorTexto
       public String accionAbrir(){
         mensaje = "Abriendo el archivo " + nombreArchivo;
         System.out.println(mensaje);
         return mensaje;
       }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/procesador-de-textov2-command.png]]
** Ejemplo 3 - Editor de Texto v3 (con HashMap)
   #+BEGIN_SRC plantuml :file diagramas-de-clases/procesador-de-textov3-command.png :exports results
     @startuml
     Title Patrón Command (Editor de Texto v2)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Command - Concrete Commands"{
         interface Command{
             +String getNombre()
             +void ejecutar()
         }

         class CommandAbrir <<Concrete Command>>{
             -EditorTexto editor

             +String getNombre()
             +void ejecutar()
         }

         class CommandCerrar <<Concrete Command>>{
             -EditorTexto editor

             +String getNombre()
             +void ejecutar()
         }

         class CommandGuardar <<Concrete Command>>{
             -EditorTexto editor

             +String getNombre()
             +void ejecutar()
         }
     }

     ''''''''''''''''''''''''''''''''''''''

     class EditorTexto <<Receptor>>{
         +void accionAbrir()
         +void accionCerrar()
         +void accionGuardar()
     }

     class MenuOpciones <<Invocador>>{
         -Map<String, Command> concreteCommands
         +void clickBoton(String nombreCommand)
         +void addConcreteCommand(Command command)
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     CommandAbrir     .u.|> Command
     CommandCerrar    .u.|> Command
     CommandGuardar   .u.|> Command

     MenuOpciones     -l-> Command

     CommandAbrir     -d-> EditorTexto
     CommandCerrar    -d-> EditorTexto
     CommandGuardar   -d-> EditorTexto

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of MenuOpciones
       public MenuOpciones(){ // constructor
         // lo inicializamos
         concreteCommands = new HashMap<>();
       }

       public void clickBoton(String nombreBoton){
         concreteCommands.get(nombreBoton).ejecutar();
       }

       public void addConcreteCommand(Command command){
         this.concreteCommands.put(command.getNombre(), command);
       }

     end note

     note bottom of CommandGuardar
       @Override
       public void ejecutar(){
         editor.accionAbrir();
       }

       @Override
       public String getNombre(){
         return "abrir";
       }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/procesador-de-textov3-command.png]]
** Ejemplo 4 - Switch de lampara
   #+BEGIN_SRC plantuml :file diagramas-de-clases/switch-lampara-command.png :exports results
     @startuml
     Title Patrón Command - Switch de una Lampara

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Command - Concrete Commands"{
         interface Command{
             +void ejecutar()
         }
    
         class CommandEncender <<Concrete Command>>{
             -Lampara receptor
             +void ejecutar()
         }
    
         class CommandApagar <<Concrete Command>>{
             -Lampara receptor
             +void ejecutar()
         }
     }

     class SwitchLampara <<Invocador>>{
         -Command command

         +void presionarSwitch()
         +void setCommand(Command command)
     }

     class Lampara <<Receptor>>{
         -boolean encendido
         +void accionEncender()
         +void accionApagar()
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     CommandEncender     .up.|> Command
     CommandApagar       .up.|> Command

     SwitchLampara       -left-> Command

     CommandEncender     -down-> Lampara
     CommandApagar       -down-> Lampara


     ' ================
     ' ==== NOTAS =====
     ' ================

     /'
     note bottom of Switch
     Si tuviera muchos concrete commands, se podría tener una
     lista de tipo **Map<String, ConcreteCommand>**
     con el nombre del comando, y la referencia al objeto en si,
     con una **relación de agregación**
     Tiene como ventaja agregar nuevos comandos concretos
     al arreglo.

     En este caso debemos pasar los comandos concretos
     en el **constructor** de la clase ControlRemoto
     end note
     '/
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/switch-lampara-command.png]]
** Ejemplo 5 - Multiples Dispositivos Electrónicos (agregar una interfaz)
   #+BEGIN_SRC plantuml :file diagramas-de-clases/dispositivos-electronicos-command.png :exports results
     @startuml
     Title Patrón Command - (Dispositivos Electrónicos)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Command - Concrete Commands"{
         interface Command{
             +void ejecutar()
         }

         class CommandEncender <<Concrete Command>>{
             -DispositivoElectronico dispositivo
             +void ejecutar()
         }

         class CommandApagar <<Concrete Command>>{
             -DispositivoElectronico dispositivo
             +void ejecutar()
         }

         class CommandApagarTodos <<Concrete Command>>{
             -List<DispositivoElectronico> dispositivos
             +void ejecutar()
         }

     }

     class ControlRemoto <<Invocador>>{
         -Command command

         +void setCommand(Command command)
         +void presionarBoton()
     }

     rectangle "Receptores"{
         interface DispositivoElectronico{
             +void accionEncender()
             +void accionApagar()    
         }

         class Lampara <<Receptor 1>>{
             +void accionEncender()
             +void accionApagar()
         }
         class Televisor <<Receptor 2>>{
             +void accionEncender()
             +void accionApagar()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     CommandEncender     .up.|> Command
     CommandApagar       .up.|> Command
     CommandApagarTodos  .up.|> Command

     ControlRemoto       -left-> Command

     Televisor           .up.|> DispositivoElectronico
     Lampara             .up.|> DispositivoElectronico

     CommandEncender     -down-> DispositivoElectronico
     CommandApagar       -down-> DispositivoElectronico
     CommandApagarTodos  -down-> DispositivoElectronico


     ' ================
     ' ==== NOTAS =====
     ' ================

     /'
     note bottom of ControlRemoto
     Si tuviera muchos concrete commands, se podría tener una
     lista de tipo **Map<String, ConcreteCommand>**
     con el nombre del comando, y la referencia al objeto en si,
     con una **relación de agregación**
     Tiene como ventaja agregar nuevos comandos concretos
     al arreglo.

     En este caso debemos pasar los comandos concretos
     en el **constructor** de la clase ControlRemoto
     end note
     '/

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/dispositivos-electronicos-command.png]]
** Ejemplo 6 - Juego MMORPG
   #+BEGIN_SRC plantuml :file diagramas-de-clases/juego-mmorpg-command.png :exports results
     @startuml
     Title Patrón Command - (Juego MMORPG)

     ' ================
     ' ==== CLASES ====
     ' ================

     class Jugador <<Cliente>>{
         +void Main()
     }

     rectangle "Command - Concrete Commands"{
         interface Command{
             +void ejecutar()
         }

         class Hechizar <<Concrete Command>>{
             -Monstruo receptor
             +void ejecutar()
         }

         class Atacar <<Concrete Command>>{
             -Monstruo receptor
             +void ejecutar()
         }
     }

     class MenuComandos <<Invocador>>{
         -Command command

         +void setCommand(Command command)
         +void clickBoton()
     }

     rectangle "Receptores"{
         interface Monstruo{
             +void recibirAtaque()
             +void recibirHechizo()
             +void atacar()
             +void defenderse()
         }

         class Goblin <<Receptor 1>>{
             +void recibirAtaque()
             +void recibirHechizo()
             +void atacar()
             +void defenderse()
         }
         class Troll <<Receptor 2>>{
             +void recibirAtaque()
             +void recibirHechizo()
             +void atacar()
             +void defenderse()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Hechizar    .up.|> Command
     Atacar      .up.|> Command

     Goblin      .up.|> Monstruo
     Troll       .up.|> Monstruo

     MenuComandos -left-> Command

     Hechizar    -down-> Monstruo
     Atacar      -down-> Monstruo

     Jugador     -u-> MenuComandos

     ' ================
     ' ==== NOTAS =====
     ' ================


     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/juego-mmorpg-command.png]]
** Ejemplo 7 - Cajero Automático
   #+BEGIN_SRC plantuml :file diagramas-de-clases/cajero-automatico-command.png :exports results
     @startuml
     Title Patrón Command (Cajero Automático)

     ' ================
     ' ==== CLASES ====
     ' ================

     rectangle "Command - Concrete Commands"{
         interface Operacion <<Command>>{
             +void ejecutar()
             +void deshacerOperacion()
         }

         class OperacionRetirar <<Concrete Command>>{
             -Cuenta cuenta
             -double monto

             +void ejecutar()
             +void deshacerOperacion()
         }

         class OperacionDepositar <<Concrete Command>>{
             -Cuenta cuenta
             -double monto

             +void ejecutar()
             +void deshacerOperacion()
         }
     }

     ''''''''''''''''''''''''''''''''''''''

     class Cuenta <<Receptor>>{
         -int numeroCuenta
         -double saldo
         +void accionRetirar(double monto)
         +void accionDepositar(double monto)
     }

     together {
         class Usuario{
             +void Main()
         }
    
         class TecladoCajero <<Invocador>>{
             -List<Operacion> operaciones
    
             +void presionarBoton(Operacion operacion)
             +void realizarOperaciones()
             +void deshacerOperaciones()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     OperacionDepositar  .up.|> Operacion
     OperacionRetirar    .up.|> Operacion

     TecladoCajero       -left-> Operacion

     OperacionDepositar  -down-> Cuenta
     OperacionRetirar    -down-> Cuenta

     Usuario             -left-> TecladoCajero

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of OperacionDepositar
       // constructor
       public OperacionDepositar(Cuenta cuenta, double monto){
         this.cuenta = cuenta;
         this.monto = monto;
       }
  
       @Override
       public void ejecutar(){
         cuenta.depositar(monto);
       }
  
       @Override
       public void deshacerOperacion(){
         cuenta.retirar(monto);
       }
     end note

     note bottom of TecladoCajero
       List<Operacion> operaciones = new ArrayList<>();
  
       public void presionarBoton(Operacion operacion){
         operaciones.add(operacion);
       }
  
       public void realizarOperaciones(){
         System.out.println("Realizando operaciones..");
         operaciones.forEach(operacion -> operacion.ejecutar());
       }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/cajero-automatico-command.png]]

* [WAITING] Observer
** Conceptos
   - El *Observable* (ó Publisher)
     1. son los objetos que quieren ser observados
     2. notifica a todos sus Observers/Suscribers si hay cambios en su estado (tiene una colección de los objetos que suscribieron a ellos)
     3. al notificar a los suscriptores, delegan en ellos la implementación de actualizar su estado (/porque tienen una referencia del suscriptor/)
   - El *Observer* (ó Suscriber)
     1. son los objetos que están atentos a cambios del *Observable*, éste les notifica si los hay
     2. se registran a un Observable concreto, delegan en ellos la implementación del registrar (/porque guardan una referencia del observado/)
** Cualidades de Diseño
   1. *Bajo acoplamiento* entre el Observado y el Observador, la comunicación es a través de sus interfaces
** Ejemplos
   1. La suscripción a newsletter, que notifica a los interesados (suscriptores que se registraron) sobre un tema en particular
** [WAITING] Ejemplo 1 - Biblioteca Libros
  #+BEGIN_COMMENT
  1. Si hubieran más clases de biblioteca (Ej. Lugano, Medrano) cada observer que quiera suscribirse a ambas,
  guardaría la referencia de la instancia de clases? BibliotecaMedrano bibliotecaA, BibliotecaLugano bibliotecaB
  
  2. El patrón de libro figura que el Observable y el Observer son interfáz, pero estaría bien que fuesen Clases Abstractas
  porque tienen estado?
  #+END_COMMENT
  
  #+BEGIN_SRC plantuml :file diagramas-de-clases/biblioteca-observer.png :exports results
    @startuml
    Title Patrón Observer + Null Object (Biblioteca - Libros)

    ' ================
    ' ==== CLASES ====
    ' ================

    package "Patrón Observer"{
        abstract BibliotecaObservable <<Observable>>{
            #Set<Observer> observadores
            #Libro libroDisponible
            +agregarObservador(Observer o)
            +quitarObservador(Observer o)
            +notificarObservadores()
        }

        class BibliotecaMedrano <<Concrete Observable>>{
            +notificarObservadores()
        }

        abstract Observer <<Observer>>{
            #Libro libroDisponible
            +actualizar(Libro libro)
        }

        class EstudianteObserver <<Concrete Observer>>{
            -Number legajo
            -BibliotecaMedrano biblioteca
            +actualizar(Libro libro)
        }

        class InvitadoObserver <<Concrete Observer>>{
            -String nombre
            -Number dni
            -BibliotecaMedrano biblioteca
            +actualizar(Libro libro)
        }
    }

    package "Null Object"{
        class LibroComun{
        +getTitulo()
        }

        class NullLibro{
        +getTitulo()
        }

        abstract class Libro{
            #String titulo
            #boolean disponible
            +getTitulo()
        }
    }

    ' ================
    ' == RELACIONES ==
    ' ================

    BibliotecaMedrano       .up.|> BibliotecaObservable
    BibliotecaObservable       -right-> Observer : notifica
    EstudianteObserver      .up.|> Observer
    InvitadoObserver      .up.|> Observer
    EstudianteObserver      -left-> BibliotecaMedrano
    InvitadoObserver      -left-> BibliotecaMedrano :observa

    'EstudianteObserver          .down.> Libro
    BibliotecaObservable   -up-> Libro
    Observer            -up-> Libro

    LibroComun  -down-|> Libro
    NullLibro  -down-|> Libro

    ' ================
    ' ==== NOTAS =====
    ' ================

    note bottom of EstudianteObserver
    ,* injectamos al observable como dependencia en el constructor

    ,* delegamos la implementación de addObserver al Observable

    --

    EstudianteObserver(String nombre, BibliotecaMedrano biblio){
        this.nombre = nombre;
        this.biblioteca = biblio;

        biblio.agregarObservador(this);
    }

    void actualizar(Libro libro){
        this.libroDisponible = libro;
    }

    // idem para desuscribirse
    void suscribirse(BibliotecaMedrano biblio){
        biblioteca.agregarObservador(this);
    }
    end note

    note bottom of BibliotecaMedrano
    ,* delegamos la implementación de actualizar al Observer

    --

    void notificarObservadores(){
        this.observadores
            .forEach(obs -> obs.actualizar(this.libroDisponible))
    }

    end note

    @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/biblioteca-observer.png]]
** Ejemplo 2 - Canal de Youtube
  #+BEGIN_SRC plantuml :file diagramas-de-clases/canal-youtube-observer.png :exports results
    @startuml
    Title Patrón Observer (Youtube)

    ' ================
    ' ==== CLASES ====
    ' ================

    package "Patrón Observer #1"{
        class CanalYoutube <<Publisher>>{
            -List<Suscriptor> suscriptores
            -int cantidadNuevosVideos
            +agregarSuscriptor(Suscriptor s)
            +quitarSuscriptor(Suscriptor s)
            +notificarSuscriptores()
        }
    
        interface Suscriptor <<Suscriber>>{
            +actualizar(int cantNuevosVideos)
        }
    
        class SuscriptorA{
            -CanalYoutube subject
            +actualizar(int cantNuevosVideos)
        }
        class SuscriptorB{
            -CanalYoutube subject
            +actualizar(int cantNuevosVideos)
        }
    }
    package "Patrón Observer #2"{
        interface ICanalYoutube <<Subject>>{
            +agregarObservador(Observador s)
            +quitarObservador(Observador s)
            +notificarObservadores()
        }
    
        class OtroCanalYoutube <<Concrete Subject>>{
            -Set<Observador> observadores
            -int cantidadNuevosVideos
            +int getCantNuevosVideos()
            +int setCantNuevosVideos(int cantVideos)
        }
    
        interface Observador <<Observer>>{
            +actualizar(int cantNuevosVideos)
        }
    
        class ObservadorA <<Concrete Observer>>{
            -OtroCanalYoutube subject
            +actualizar(int cantNuevosVideos)
        }
        class ObservadorB <<Concrete Observer>>{
            -OtroCanalYoutube subject
            +actualizar(int cantNuevosVideos)
        }
    }
    ' ================
    ' == RELACIONES ==
    ' ================

    CanalYoutube    o-right-> Suscriptor
    SuscriptorA     .up.|> Suscriptor
    SuscriptorB     .up.|> Suscriptor

    SuscriptorA     -up-> CanalYoutube
    SuscriptorB     -up-> CanalYoutube

    OtroCanalYoutube    .up.|> ICanalYoutube
    OtroCanalYoutube    o-right-> Observador
    ObservadorA         .up.|> Observador
    ObservadorB         .up.|> Observador

    ObservadorA         o-u-> OtroCanalYoutube
    ObservadorB         o-u-> OtroCanalYoutube

    ' ================
    ' ==== NOTAS =====
    ' ================


    @enduml
  #+END_SRC

  #+RESULTS:
  [[file:diagramas-de-clases/canal-youtube-observer.png]]
* Null Object
** Ejemplo 1 - Clientes Premium
   #+BEGIN_SRC plantuml :file diagramas-de-clases/clientes-nullobject.png :exports results
     @startuml
     Title Patrón Null Object (Crear clientes)

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón Null Object + Method Factory" as A{
         abstract class Cliente <<Abstract Object>>{
             -String nombre
             +{abstract} String getNombre()
             +{abstract} boolean isNull()
         }

         class ClienteNormal <<Concrete Object>>{
             +{abstract} boolean isNull()
         }

         class ClientePremium <<Concrete Object>>{
             +{abstract} boolean isNull()
         }

         class NullCliente <<Null Object>>{
             +String getNombre()
             +{abstract} boolean isNull()
         }

         interface IClienteFactory{
             +{static} Cliente crearCliente(String nombre, String tipo)
         }
    
         class ClienteFactory{
             +{static} Cliente crearCliente(String nombre, String tipo)
         }

     }


     ' ================
     ' == RELACIONES ==
     ' ================

     ClienteNormal   -up-|> Cliente
     ClientePremium  -up-|> Cliente
     NullCliente     -up-|> Cliente

     IClienteFactory  .right.> Cliente
     ClienteFactory  .up.|> IClienteFactory


     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of NullCliente
       @Override
       public boolean isNull(){
         return true;
       }

       @Override
       public String getNombre(){
         ,**return "NO existe";**
       }
     end note

     note bottom of ClienteNormal
       @Override
       public boolean isNull(){
         return false;
       }

       @Override
       public String getNombre(){
         return nombre;
       }
     end note

     note bottom of ClienteFactory
       public **static** Cliente crearCliente(String nombre, String tipo){
         if("premium".equalsIgnoreCase(tipo)){
           return new ClientePremium(nombre);
         }
         else if("normal".equalsIgnoreCase(tipo)){
           return new ClienteNormal(nombre);
         }

         ,**return new NullCliente();**
       }
     end note
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/clientes-nullobject.png]]

* State
** Objetivo
   - Aparecen hay muchos condicionales (se tiende a crear una clase por cada rama de condicional como estado)
   - Si _el comportamiento del objeto depende de su estado_ (/Ej. un semáforo, una conexión cliente_servidor, el estado de una cta bancaria, .../)
   - Cada cambio de estado interno, hace que cambie el comportamiento del objeto
** Ejemplo 1 - Pantalla celular
   #+BEGIN_SRC plantuml :file diagramas-de-clases/pantalla-celular-state.png :exports results
     @startuml
     Title Patrón State (Pantalla Celular)

     ' ================
     ' ==== CLASES ====
     ' ================

     class Pantalla <<Context>>{
         -EstadoPantalla estado
         +void presionarPantalla()
         +void presionarBotonEncendido()
     }

     interface EstadoPantalla <<State>>{
         +void presionarPantalla(EstadoPantalla estado)
         +void presionarBotonEncendido(EstadoPantalla estado)
     }

     class EstadoEncendido <<Concrete State>>{
         +void presionarPantalla(EstadoPantalla estado)
         +void presionarBotonEncendido(EstadoPantalla estado)
     }

     class EstadoApagado <<Concrete State>>{
         +void presionarPantalla(EstadoPantalla estado)
         +void presionarBotonEncendido(EstadoPantalla estado)
     }

     class EstadoStandBy <<Concrete State>>{
         +void presionarPantalla(EstadoPantalla estado)
         +void presionarBotonEncendido(EstadoPantalla estado)
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     Pantalla    *-right-> EstadoPantalla

     EstadoApagado     .up.|> EstadoPantalla
     EstadoEncendido    .up.|> EstadoPantalla
     EstadoStandBy     .up.|> EstadoPantalla

     ' ================
     ' ==== NOTAS =====
     ' ================

     note left of Pantalla
       public PantallaCelular(){ // constructor
         // le asignamos un estado por defecto
         estadoPantalla = new EstadoApagado();
       }
  
       public void presionarPantalla(){
         // delegamos en otro objeto, le pasamos la pelota a él
         // y le pasamos por parametro el propio objeto "Pantalla"
         // para que el otro pueda alternar entre estados
         ,**estadoPantalla.presionarPantalla(this);**
       }
  
       public void presionarBotonEncendido(){
         ,**estadoPantalla.presionarBotonEncendido(this);**
       }
     end note

     note bottom of EstadoEncendido
       @Override
       public void presionarPantalla(PantallaCelular pantalla){
         System.out.println("Abriendo alguna aplicación del celular..");
       }
  
       @Override
       public void presionarBotonEncendido(PantallaCelular pantalla){
         System.out.println("Apagando el celular...");
    
         // hacemos un cambio de estado (pasamos a otra transición)
         ,**pantalla.setEstado(new EstadoApagado());**
       }
     end note

     note bottom of EstadoApagado
       @Override
       public void presionarPantalla(PantallaCelular pantalla){
         System.out.println("Nada sucederá, la pantalla está apagada");
       }
  
       @Override
       public void presionarBotonEncendido(PantallaCelular pantalla){
         System.out.println("Encendiendo celular...");
    
         // hacemos un cambio de estado (pasamos a otra transición)
         ,**pantalla.setEstado(new EstadoEncendido());**
       }
     end note

     @enduml
  #+END_SRC

  #+RESULTS:
  [[file:diagramas-de-clases/pantalla-celular-state.png]]
** Ejemplo 2 - Estado Servidor Web
   #+BEGIN_SRC plantuml :file diagramas-de-clases/estado-servidorweb-state.png :exports results
     @startuml
     Title Patrón State (Estado Servidor Web)

     ' ================
     ' ==== CLASES ====
     ' ================

     class Servidor <<Context>>{
         -EstadoServidor estado
    
         +void encender()
         +void reiniciar()
         +void bloquear()
         +void apagar()
         +void imprimirEstado()
     }

     interface EstadoServidor <<State>>{
         +void encender(Servidor servidor)
         +void reiniciar(Servidor servidor)
         +void bloquear(Servidor servidor)
         +void apagar(Servidor servidor)
         +void imprimirEstado()
     }

     class EstadoApagado <<Concrete State>>{
         +void encender(Servidor servidor)
         +void reiniciar(Servidor servidor)
         +void bloquear(Servidor servidor)
         +void apagar(Servidor servidor)
         +void imprimirEstado()
     }

     class EstadoEncendido <<Concrete State>>{
         +void encender(Servidor servidor)
         +void reiniciar(Servidor servidor)
         +void bloquear(Servidor servidor)
         +void apagar(Servidor servidor)
         +void imprimirEstado()
     }

     class EstadoBloqueado <<Concrete State>>{
         +void encender(Servidor servidor)
         +void reiniciar(Servidor servidor)
         +void bloquear(Servidor servidor)
         +void apagar(Servidor servidor)
         +void imprimirEstado()
     }

     class EstadoReiniciando <<Concrete State>>{
         +void encender(Servidor servidor)
         +void reiniciar(Servidor servidor)
         +void bloquear(Servidor servidor)
         +void apagar(Servidor servidor)
         +void imprimirEstado()
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     EstadoEncendido  .up.|> EstadoServidor : implementa
     EstadoReiniciando    .up.|> EstadoServidor : implementa
     EstadoBloqueado    .up.|> EstadoServidor : implementa
     EstadoApagado    .up.|> EstadoServidor : implementa

     Servidor         *-right-> EstadoServidor

     ' ================
     ' ==== NOTAS =====
     ' ================

     note left of Servidor
     El servidor guarda una referencia del estado
     para que ellos puedan acceder y cambiar a otro

     El objeto servidor delegará la tarea en el Estado
     y se pasará así mismo por parámetro

     ,**void encender(){ estado.encender(this) ; }**
     end note

     note as N1
     Habrá tantas clases como transiciones de estados

     Cada clase tiene su propio comportamiento,
     por eso sobreescriben los métodos

     Los métodos que reciben de parámetro al Servidor,
     es para poder alternar a otro estado
     end note

     N1 .up. EstadoApagado
     N1 .up. EstadoBloqueado
     N1 .up. EstadoReiniciando
     N1 .up. EstadoEncendido

     @enduml
  #+END_SRC

  #+RESULTS:
  [[file:diagramas-de-clases/estado-servidorweb-state.png]]
** Ejemplo 3 - Supermercado atención cliente
   #+BEGIN_SRC plantuml :file diagramas-de-clases/caja-supermercado-estado-state.png :exports results
     @startuml
     Title Patrón State (Supermercado - Atención)

     ' ================
     ' ==== CLASES ====
     ' ================

     class Supermercado{
         -String nombre
         -List<Caja> cajas
     }

     class Cliente{
         -String nombre
         -int edad
         +boolean esMayorDeEdad()
     }

     package "Patrón State"{
         class Caja <<Context>>{
             -EstadoCaja estado
             -int numeroCaja
             -String nombreCajero
        
             +void atender(Persona p)
             +void abrir()
             +void cerrar()
         }
    
         interface EstadoCaja <<State>>{
             +void atender(Persona p)
             +void abrir(Caja caja)
             +void cerrar(Caja caja)
         }
    
         class CajaCerrada <<Concrete State>>{
             +void atender(Persona p)
             +void abrir(Caja caja)
             +void cerrar(Caja caja)
         }
    
         class CajaAbierta <<Concrete State>>{
             +void atender(Persona p)
             +void abrir(Caja caja)
             +void cerrar(Caja caja)
         }
    
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Supermercado o-right-> Caja

     Caja        *-right-> EstadoCaja
     Caja        -right-> Cliente

     CajaCerrada .up.|> EstadoCaja
     CajaAbierta .up.|> EstadoCaja

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of CajaCerrada
       @Override
       public void abrir(Caja caja){
         System.out.println("Abriendo la caja "+ caja.getNumeroCaja());
         ,**caja.setEstado(new CajaAbierta());**
       }
  
       @Override
       public void cerrar(Caja caja){
         System.out.println("La caja "+caja.getNumeroCaja()+" ya está cerrada");
       }
     end note

     note bottom of CajaAbierta
       @Override
       public void abrir(Caja caja){
         System.out.println("La caja "+caja.getNumeroCaja()+" ya está abierta");
       }

       @Override
       public void cerrar(Caja caja){
         System.out.println("Cerrando la caja..");
         ,**caja.setEstado(new CajaCerrada());**
       }
     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/caja-supermercado-estado-state.png]]

* [DONE] Facade (Simplicidad ante subsistemas complejos)
CLOSED: [2021-12-06 lun 21:04]
** Conceptos
   - La *fachada* es el nexo/puente entre el *cliente* y los *servicios* ó *subsistemas complejos*
   - Mejora la interfaz de comunicación entre dos objetos
   - _Oculta la complejidad de entender como tratar con un conjunto de subsistemas complejos_, expone una _interfaz sencilla que simplifica la complejidad_
   - La usamos SIEMPRE que usemos una *biblioteca de terceros* (ajena a nuestro sistema)
     - porque la biblioteca tiene demasiadas features que el cliente NO necesita
     - porque la biblioteca agrega un nivel de complejidad que el cliente no necesita porque entender
   - Cuando un sistema que tiene varios servicios se hace complejo de usar
     (se evita que cliente el tenga que entender el contexto de como funciona cada servicio)
** Cualidades de Diseño
   - *Bajo acoplamiento* entre el cliente y los servicios ó subsistemas
   - *Mantenimiento* a la clase que hace de fachada de los servicios ó subsistemas
** Problemas que resuelve
   1. Un cliente necesita acceder a una funcionalidad de un sistema complejo (/exponer una interfaz que sólo exponga esa funcionalidad/)
   2. Una biblioteca externa dificil de entender (/exponer una interfaz con operaciones más entendibles. Ej. en jQuery $.get() y $.post() son fachadas de $.ajax()/)
   3. Acceder a un conjunto de APIs que no tienen buen diseño (/exponer una API interna de fachada/)
   4. Conjunto de tareas frecuentes (/agrupar las tareas en una tarea/)
** Ejemplo Genérico - Fachada de Servicios
   #+BEGIN_SRC plantuml :file diagramas-de-clases/facade-generico1.png :exports results
     @startuml
     Title Patrón Facade

     ' ================
     ' ==== CLASES ====
     ' ================

     class Cliente{
     }

     interface IFachada{
         +void operacionABC()
     }

     class Fachada{
         +void operacionABC()
     }

     rectangle "Servicios externos"{
         class ServicioA{
             +void operacionA()
         }
    
         class ServicioB{
             +void operacionB()
         }
    
         class ServicioC{
             +void operacionC()
         }
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     Cliente     -right-> Fachada

     Fachada     .up.|> IFachada

     Fachada     .down.> ServicioA : usa
     Fachada     .down.> ServicioB : usa
     Fachada     .down.> ServicioC : usa

     ' ================
     ' == COMENTARIOS ==
     ' ================

     note right of Fachada
     Oculta la complejidad de los servicios
     --
     void operacionABC(){
         operacionA()
         operacionB()
         operacionC()
     }
     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/facade-generico1.png]]
** Ejemplo 1 - Subsistema de Pedidos
   #+BEGIN_SRC plantuml :file diagramas-de-clases/facade-subsistema-de-pedidos.png :exports results
     @startuml
     Title Patrón Facade - Fachada de un Subsistema de Pedidos

     ' ================
     ' ==== CLASES ====
     ' ================

     class Cliente{
     }

     interface IPedidoFachada{
         +boolean hayStockDisponible()
         +void agregarATarjeta()
         +void removerDeTarjeta()
         +void realizarPedido()
     }

     class PedidoFachada<<Facade>>{
         -Stock stock
         -Tarjeta tarjeta
         -Pago pago

         +boolean hayStockDisponible()
         +void agregarATarjeta()
         +void removerDeTarjeta()
         +void realizarPedido()

     }

     rectangle "Subsistema de Pedido"{
         class Stock{
             +boolean comprobarStock()
         }

         class Tarjeta{
             +void agregarPedido()
             +void removerPedido()
             +void comprobarPedido()
         }

         class Pago{
             +void comprobarPago()
         }
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     Cliente     -right-> PedidoFachada

     PedidoFachada     .up.|> IPedidoFachada

     PedidoFachada     .down.> Stock : usa
     PedidoFachada     .down.> Pago : usa
     PedidoFachada     .down.> Tarjeta : usa

     ' ================
     ' == COMENTARIOS ==
     ' ================

     note right of PedidoFachada
     ,* Implementación de la interfaz de alto nivel
     que __oculta la complejidad del subsistema__
             
     ,* __Unico punto de entrada de comunicación__
     con el subsistema de pedidos
     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/facade-subsistema-de-pedidos.png]]

** Ejemplo 2 - Impresión de Documentos
   #+BEGIN_SRC plantuml :file diagramas-de-clases/servicio-impresion-facade.png :exports results
     @startuml
     Title Patrón Facade (Impresión de Documentos)

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón Facade (Ofrece simplicidad al cliente)" as A{
         class Oficina <<Cliente>>{
         }

         class ServicioImpresion <<Facade>>{
             -Documento Documento

             +void imprimirFirmadoYValidado(Documento doc)
         }

         class "Documento" as Documento2{
             -int numeroDocumento
             -String titulo
         }

         class "ServicioImprimir" as ServicioImprimir2{
             +void imprimir(Documento doc)
         }

         class "ServicioValidar" as ServicioValidar2{
             +void validar(Documento doc)
         }

         class "ServicioFirmaDigital" as ServicioFirmaDigital2{
             +void firmar(Documento doc)
         }

    
         note top of Oficina
         Documento documentoLegal = new Documento(101, "Ley 1001");
         ServicioImpresion.imprimirFirmadoYValidado(documentoLegal);
         end note
    
         note top of ServicioImpresion
         void imprimirFirmadoYValidado(Documento doc){
             ServicioFirmar.firmar(doc)
             ServicioValidar.validar(doc)
             ServicioImprimir.imprimir(doc)
         }
         end note
     }

     package "SIN Patrón Facade (Agrega complejidad para el cliente)" as B{

         note as A
         El cliente requiere saber como manejar
         muchos servicios le complicamos el uso

         ,**Solución:**
         Hacer una fachada que agrupe los servicios
         y simplificar su uso.

        ,**Nota**
         Si el sistema crece y se torna complejo,
         y también la fachada, entonces se
         pueden modelar nuevas fachadas
         end note

         class Cliente{
             -Documento Documento
         }

         class Documento{
             -int numeroDocumento
             -String titulo
         }

         class ServicioImprimir{
             +void imprimir(Documento doc)
         }

         class ServicioValidar{
             +void validar(Documento doc)
         }

         class ServicioFirmaDigital{
             +void firmar(Documento doc)
         }
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     Cliente .down.> ServicioValidar
     Cliente .down.> ServicioFirmaDigital
     Cliente .down.> ServicioImprimir
     Cliente -right-> Documento


     Oficina .right.> ServicioImpresion
     ServicioImpresion .down.> ServicioValidar2
     ServicioImpresion .down.> ServicioFirmaDigital2
     ServicioImpresion .down.> ServicioImprimir2
     ServicioImpresion -right-> Documento2

     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/servicio-impresion-facade.png]]
* [DONE] Adapter (Adaptar la Interfaz de Servicios/Bibliotecas)
CLOSED: [2021-12-06 lun 21:04]
** Conceptos
   - Convierte una interfaz en otra, sin agregar funcionalidad
   - Cuando dos programas tienen misma funcionalidad pero tienen interfaces incompatibles (/los mensajes que entienden son diferentes/)
   - Permite que dos programas se comuniquen sin modificar la implementación de ninguno
   - Cuando nuestra aplicación interactúa con servicios externos que exponen una API con operaciones incompatibles a las de nuestro dominio
   - El *Adaptader* es nexo/puente de la comunicación entre nuestra aplicación y una *API* de terceros (/google maps, servicio de mail, .../)
   - El *Adaptader* traduce las operacionesEspecificas del *Adaptee*, las adapta para que el *Cliente* pueda usarlas con las operaciones que conoce

   #+BEGIN_COMMENT
   Cuando no podemos usar la *Herencia* para agregar comportamiento a la implementación de una clase,
   porque esta pertenece a una biblioteca de terceros ó a un servicio externo.

   Creamos una clase *Adapter* que guarda la referencia del objeto *Adaptee* del que queremos
   agregar lógica a nuestra aplicación, pero tiene una interfáz distinta al dominio de la aplicación.

   El *Adapter* implementa la interfáz con los mensajes que la aplicación entiende,
   y los reescribimos usando las operacionesEspecificas del objeto (Adaptee), que queríamos agregar a la aplicación
   #+END_COMMENT
** Ventajas
   - Si la *API* de terceros llegase a cambiar => solo modificaríamos nuestro *adapter*
     (si no lo tuvieramos, deberíamos buscar/modificar en todo el programa que use métodos de esa API de terceros)
** Cualidades de Diseño
   - *Bajo acoplamiento* entre la aplicación y los servicios externos y/o bibliotecas de terceros que usa, se comunican a través del *Adapter*
** Ejemplo Genérico 1 - Herencia Vs Composición/Inyección de Dependencia
   #+BEGIN_SRC plantuml :file diagramas-de-clases/adapter-herencia-y-inyeccion-dependencias.png :exports results
     @startuml
     Title Patrón Adapter

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón Adapter #1 - Herencia"{
         class "Client" as client1{
             -Adapter adapter
             +doSomething()
         }

         interface "Target" as target1{
             +operacion()
         }
    
         class "Adapter" as adapter1{
             +operacion()
         }
    
         class "Adaptee" as adaptee1{
             +operacionEspecifica()
         }
     }

     package "Patrón Adapter #2 - Composición / Inyección de Dependencias"{
         class "Client" as client2{
             -Adapter adapter
             +doSomething()
         }

         interface "Target" as target2{
             +operacion()
         }
    
         class "Adapter" as adapter2{
             -Adaptee adaptee
             +Adapter()
             +operacion()
         }
    
         class "Adaptee" as adaptee2{
             +void operacionEspecifica()
         }
     }

     ' ================
     ' == RELACIONES ==
     ' ================

     adapter1    .up.|> target1
     adapter1    -up-|> adaptee1
     client1     -right-> adapter1

     adapter2    .up.|> target2
     adapter2    -up-> adaptee2
     client2     -right-> adapter2

     ' ================
     ' ==== NOTAS =====
     ' ================

     note bottom of client2
     doSomesthing(){
         adapter.operacion();
     }
     end note

     note right of adaptee2
     ,* Una biblioteca de terceros

     ,* Un servicio externo al que pedimos datos y
     que expone una interfaz (Ej. gmaps, iweather, ..)
     end note


     note bottom of adapter2
     ,* Implementa la interfaz que necesita el cliente

     ,* Permite la comunicación entre los objetos que
     tienen interfaces incompatibles

     ,* __Se inyecta el objeto Adaptee como dependencia__
     al Adapter (en este caso por constructor)

     --

     class Adapter implements Target{
         Adaptee adaptee;
    
         Adapter(Adaptee adaptee){ // constructor
             this.adaptee = adaptee
         }
    
         @Override
         operacion(){
             adaptee.operacionEspecifica();
         }
     }
     end note

     note bottom of adapter1
     ,* Utiliza la herencia y adapta el comportamiento
     que es incompatible con la interfaz del dominio.

     ,* NO sería aplicable, si el objeto a adaptar
     es un servicio externo. En ese caso deberíamos
     optar por __inyección de dependencias__

     --

     class Adapter extends Adaptee implements Target{
         @Override
         void metodo(){
             this.metodoEspecifico();
         }
     }
     end note
     @enduml
  #+END_SRC

  #+RESULTS:
  [[file:diagramas-de-clases/adapter-herencia-y-inyeccion-dependencias.png]]
** Ejemplo 1 - Contactos - Multiples Adaptees y Adapters
   #+BEGIN_SRC plantuml :file diagramas-de-clases/adapter-contactos.png :exports results
     @startuml
     Title Patrón Adapter - Contactos

     ' ================
     ' ==== CLASES ====
     ' ================

     class App<<Cliente>>{
     }

     class Contacto{
         String nombre
     }

     interface IContactosAdapter{
         +List<Contacto> getContactos()
     }

     class WhatsappContactosAdapter<<Adapter>>{
         -WhatsappContactosApi api
         +List<Contacto> getContactos()
         -List<Contacto> parseContactsXml(String xml)
     }

     class TelegramContactosAdapter<<Adapter>>{
         -TelegramContactosApi api
         +List<Contacto> getContactos()
         -List<Contacto> parseContactsJson(String json)
     }

     class WhatsappContactosApi<<Adaptee>>{
         +String getContactosXml()
     }

     class TelegramContactosApi<<Adaptee>>{
         +String getContactosJsonl()
     }


     ' ================
     ' == RELACIONES ==
     ' ================

     App                     -right-> IContactosAdapter
     IContactosAdapter           -right-> Contacto

     WhatsappContactosAdapter    .up.|> IContactosAdapter
     TelegramContactosAdapter    .up.|> IContactosAdapter

     WhatsappContactosAdapter    -down-> WhatsappContactosApi
     TelegramContactosAdapter    -down-> TelegramContactosApi

     ' ================
     ' ==== NOTAS =====
     ' ================

     legend
     ,**Contexto**
     Consumimos el mismo tipo de información de varios servicios (Telegram, Whatsapp),
     creamos un Adapter para cada uno, que implementa la interfaz con las operaciones
     que el dominio necesita.
     Ojo..! __El adapter sólo traduce/adapta las operaciones, no agrega nuevas funcionalidades.__

     ,**Problema**
     ,* Queremos consumir información de un Servicio (Adaptee)

     ,* El servicio expone una API incompatible con la interfaz del objeto Cliente
     que tiene el dominio de la app

     ,* El servicio es externo, sólo podemos usar la interfaz, no lo podemos modificar

     ,**Solución**
     ,* Creamos un Adapter que actúa como traductor entre el Cliente y el Servicio externo

     ,* El Adapter implementa la interfáz con las operaciones que el cliente necesita,
     y adapta las operacionesEspecificas del Servicio externo para que el Cliente lo entienda.
     end legend

     note bottom of TelegramContactosAdapter
     List<Contacto> getContactos(){
         return this.parseContactsJson(api.getContactosJson())
     }

     end note

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/adapter-contactos.png]]

** Ejemplo 2 - Dispositivos Electronicos
   #+BEGIN_SRC plantuml :file diagramas-de-clases/dispositivos-electronicos-adapter.png :exports results
     @startuml
     Title Patrón Adapter (Dispositivos Electrónicos)

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón Adapter"{
         class Cliente{
         Conectable dispositivo
         }

         abstract class Conectable <<Target>>{
             -boolean encendido
             +void encender()
             +void apagar()
             +boolean estaEncendido()
         }

         class RadioDigital{
             +void encender()
             +void apagar()
         }

         class TelevisorModerno{
             +void encender()
             +void apagar()
         }

         class TelevisorViejo <<Adaptee>>{
             +void girarPerillaAIzquierda()
             +void girarPerillaADerecha()
             +void presionarBoton()
         }

         class TelevisorViejoAdapter <<Adapter>>{
             -TelevisorViejo televisor
             +void encender()
             +void apagar()
             +boolean estaEncendido()
         }

     note left of TelevisorViejo
     void presionarBoton(){
         if(this.perillaIzquierda){
             this.encendido = true;
         }else if(this.perillaDerecha){
             this.encendido = false;
         }
     }

     void estaEncendido(){
         return this.encendido;
     }
     end note

     note bottom of TelevisorViejoAdapter
     El **Adapter** sólo traduce/adapta las operaciones
     del **Adaptee** para que el Cliente lo entienda,
     no se agrega funcionalidad extra.

     --

     // injectamos el objeto como dependencia en el constructor
     TelevisorViejoAdapter(TelevisorViejo televisor){
         this.televisor = televisor;
     }

     void encender(){
         televisor.girarPerillaIzquierda();
         televisor.presionarBoton();
     }

     void estaEncendido(){
         return televisor.estaEncendido();
     }
     end note

     }

     ' ================
     ' == RELACIONES ==
     ' ================

     Cliente                 -right-> Conectable
     TelevisorModerno        -up-|> Conectable
     RadioDigital            -up-|> Conectable
     TelevisorViejoAdapter -up-|> Conectable

     TelevisorViejoAdapter -down-> TelevisorViejo

     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/dispositivos-electronicos-adapter.png]]
** Ejemplo 3 - Reproductores de Música
   #+BEGIN_SRC plantuml :file diagramas-de-clases/reproductor-musica-adapter.png :exports results
     @startuml
     Title Patrón Adapter (Reproductores de música)

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón Adapter (adaptar interfaces incompatibles)"{

         component "Reproductor Estandar"{
             interface IReproductor <<Adaptee>>{
                 +void reproducirMP4(String archivo)
                 +void reproducirMPG(String archivo)
             }
        
             class ReproductorMP4{
                 +void reproducirMP4(String archivo)
                 +void reproducirMPG(String archivo)
             }
        
             class ReproductorMPG{
                 +void reproducirMP4(String archivo)
                 +void reproducirMPG(String archivo)
             }
         }
    
         interface IMiniReproductor <<Target>>{
             +void reproducir(String formato, String archivo)
         }

         class MiniReproductor {
             -ReproductorAdapter reproductorAdapter
             +void reproducir(String formato, String archivo)
         }
    
         class ReproductorAdapter <<Adapter>>{
             +void reproducir(String formato, String archivo)
         }

         note top of ReproductorAdapter
         Se busca que el **MiniReproductor** pueda usar nuevos
         formatos de audio (MP4 y MPG) además del que tiene

         Se crea un adapter como puente entre las interfaces incompatibles.
         Para que las interfaz **IReproductor** de los reproductores 
         de MP4 y MPG sea compatible con la del **MiniReproductor**
         ya que entienden otros mensajes **reproducirMP4()** y **reproducirMPG()**
         end note

     }

     ' =====================
     ' ==== RELACIONES =====
     ' =====================

     ReproductorMP4              .up.|> IReproductor : implementa
     ReproductorMPG              .up.|> IReproductor : implementa

     ReproductorAdapter        -down-> IReproductor
     ReproductorAdapter        .up.|> IMiniReproductor
     MiniReproductor             .up.|> IMiniReproductor

     MiniReproductor             -right-> ReproductorAdapter : usa



     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:diagramas-de-clases/reproductor-musica-adapter.png]]

* (DI) Inyeccion de Dependencias Vs. (IoC) Inversión de Control
** (DI) Inyección de Dependencias
*** Conceptos
   #+BEGIN_QUOTE
   *(DI) Dependency Injection:*
   Es una técnica (patrón de diseño) donde a un objeto se le proveen (inyectan) las dependencias que necesita (objetos, valores, ...)
   en lugar de ser el responsable de crearlas.
   
   Separa la construcción de la ejecución, y se utiliza normalmente con *servicios* (mail, google map, etc..)
   #+END_QUOTE

   - es una especialización del *IoC* porque
     1) un Objeto A cede el control (inversión de control) a otro Objeto B (delega)
     2) se delega la creación de las *dependencias* que un objeto necesita
   - favorece el *desacoplamiento* entre un objeto y la creación de sus dependencias
     - se desliga, se desentiende de su creación
     - favorece el testing porque...
     - si está muy acoplado/atado a la creación de dependencias, cuando se agrega una nueva (usar sql en vez de mysql) dificulta el refactor
   - ejemplos de frameworks que aplican esto son: spring para java, angular para javascript, ..
*** Contenedores de inyección de dependencias (ó Contenedores de Servicios)
    - Se conocen también como *inyector de dependencias*
    - Se utiliza cuando la inyección de dependencias se vuelve compleja
      - porque una dependencia puede tener muchas otras, y esta otras tantas (se podría ver como un árbol de dependencias)
      - compleja en el sentido, si nosotros queremos implementarlo/desarrollarlo,
        por eso hay herramientas como los frameworks que lo facilitan
*** Patrones para implementarlo
    Se puede implementar con alguno de los sig. patrones de diseño
    - Factory Method
    - Abstract Factory
    - Service Locator
*** Diagrama de clases
   #+BEGIN_SRC plantuml :file diagramas-de-clases/inyeccion-dependencias.png :exports results
     @startuml
     Title Patrón (DI) Dependency Injection - Inyección de Dependencias

     ' ================
     ' ==== CLASES ====
     ' ================

     package "Patrón DI (Inyección por constructor)" as A{

         note top of ClienteA
         // constructor
         public Cliente(**Database conexion**){
            this.conexion = conexion;
         }
         public void buscar(Cliente cli){
            conexion.buscar(cli.getID());
         }
         end note
    
         class ClienteA{
             -int codigoCliente
             -Database conexion;
         }
    
         interface Database{
             +void buscar(int id)
         }
    
         class SqlServerDB{
             +void buscar(int id)
         }

         class MySQLDB{
             +void buscar(int id)
         }

         class OracleDB{
             +void buscar(int id)
         }


     }

     package "SIN Patrón DI ()" as B{
         note top of ClienteB
        public ClienteB(){
            // Mucho "acoplamiento" con SQLServerDB
            conexion = new SQLServerDB();
        }

        public void buscar(Cliente cli){
            conexion.buscar(cli.getID());
        }
        end note

         class ClienteB{
             -int codigoCliente
             -SqlServerDatabase conexion;
         }
    
         class SqlServerDatabase{
             +void buscar(int id)
         }

     }


     ' ================
     ' == RELACIONES ==
     ' ================

     ClienteB      -right-> SqlServerDatabase

     ClienteA      -right-> Database
     SqlServerDB   .up.|> Database
     MySQLDB      .up.|> Database
     OracleDB     .up.|> Database


     ' ================
     ' ==== NOTAS =====
     ' ================

     @enduml
    #+END_SRC

    #+RESULTS:
    [[file:diagramas-de-clases/inyeccion-dependencias.png]]

*** Ejemplos con Frameworks
**** Ejemplo 1
   Cuando usamos frameworks, estos inyectan las dependencias que necesitamos en los objetos
   por genera se hace con una notación @nombreNotación en (Angular se usa @Inject , en Spring se usa @AutoWhile)
 
   Los frameworks te proveen que se puede hacer inyección directo en los atributos

   También se puede fijar las dependencias en un archivo de configuración de propiedades (ej. en .yaml)
   pudiendo cambiar entre motores de base de datos, y ocurre luego de correr nuevamente la aplicación
**** Ejemplo 2
   Un ejemplo seria un sistema que utiliza una conexión a base de datos, unicamente con sql server y usa el método ~conectar()~
   entonces nuestro modelo está acoplado/atado a un solo motor de db.
 
   Pero.. y si luego se agrega posibilidad de conectarse a nuevos motores como mysql, postgr, etc..? 
   Una MALA PRACTICA seria que en nuestro ~main~ creemos las instancias a las clases de conexión de esas base de datos,

   una BUENA PRACTICA sería _delegar la creación de esos objetos de conexión_ a otro objeto ó framework, 
   para que sea más fácil alternar entre las distintas base de datos, y desentendernos de su creación..
   Esto sería "inversión de control" porque delegamos/cedemos el control a otro objeto, y que se encargue él
** Métodos de Inyección de Dependencias en JAVA
*** SIN inyección de dependencias
    Veremos que NO hay inyección de dependencias, si los objetos crean otros objetos que necesitan para funcionar.
    La *inyección de dependencias* se enfoca en que la creación de los objetos se haga en un lugar que NO sea el 
    mismo donde se inicializa, es decir que delegar su creación en otro objeto diferente.
**** Ejemplo 1
     #+BEGIN_SRC java
       public class ClienteSinInyeccion {
           private IServicioBaseDeDatos conexion;

           public ClienteSinInyeccion(){
               // - Hay un gran nivel de "acoplamiento" con SQLServerDB
               conexion = new SQLServerDB();
           }

           public void buscarCliente(Cliente cliente){
               conexion.buscarPorID("clientes", cliente.getID());
           }
       }
     #+END_SRC
**** Ejemplo 2
     *Problemas:*
     - La clase ~Programador~ está FUERTEMENTE acoplada a los objetos ~Linux~ y ~Javascript~
     - Si queremos crear otro programador con otros datos, debemos crear otra clase

     #+BEGIN_SRC java
       class Programador{
           ISistemaOperativo sistemaOperativo;
           ILenguaje lenguaje;

           // constructor
           public Programador(){
               // acá hay indicios de que "NO HAY INYECCION DE DEPENDENCIAS" <--- PROBLEMAS
               // 1. creamos los objetos
               // 2. en el mismo lugar donde los inicializamos :(
               this.sistemaOperativo = new Linux();
               this.lenguaje = new Javascript();
           }
       }

       pedrito = new Programador();
     #+END_SRC
*** Inyección por Constructor
    Un uso inadecuado puede ocasionar un constructor con muchos parámetros (code smell)
**** Ejemplo 1
     #+BEGIN_SRC java
       public class ClienteInyeccionPorConstructor{
           // creamos un atributo para guardar la referencia
           private IServicioBaseDeDatos conexion;
           // constructor
           public ClienteInyeccionPorConstructor(IServicioBaseDeDatos conexion){
               // nos desligamos de la creación del objeto, 
               // lo recibiremos ya creado (instancia) por parámetro en el constructor
               this.conexion = conexion;
           }
           public void buscarCliente(Cliente cliente){
               conexion.buscarPorID("clientes", cliente.getID());
           }
       }
     #+END_SRC
**** Ejemplo 2
     #+BEGIN_SRC java
       class Programador{
           ISistemaOperativo sistemaOperativo;
           ILenguaje lenguaje;

           // constructor
           // - en el constructor estamos "Inyectando las dependencias" (objetos) que
           // necesita la clase "Programador"..
           // - no estamos creando los objetos, solo los estamos recibiendo por parámetro
           public Programador(ISistemaOperativo sistemaOperativo, ILenguaje lenguaje){ // <-- buen indicio
               this.sistemaOperativo = sistemaOperativo;
               this.lenguaje = lenguaje;
           }
       }

       // supongamos que Linux es una clase implementa la interfaz ISistemaOperativo,
       // y.. que Javascript implementa ILenguaje
       pedrito = new Programador(new Linux(),new Javascript());
     #+END_SRC
**** Ejemplo 3
      #+BEGIN_SRC java
        public class Cliente{
            public void ejecutar(){
                RepositorioUsuario repositorioUsuario = new RepositorioUsuario();
                SevicioAutenticacion servicioAutenticacion = new ServicioAutenticacion(repositorioUsuario); //

                servicioAutenticacion.iniciarSesion(new Credenciales());
            }
        }

        // En esta clase aparece la inyección de dependencia por constructor
        public class ServicioAutenticacion{
            // creamos un atributo para guardar la referencia pasada por parámetro en el constructor
            private IRepositorioUsuario repositorioUsuario;

            public ServicioAutenticacion(IRepositorioUsuario repositorioUsuario){ // <--- inyección de dependencia en el Constructor
                this.repositorioUsuario = repositorioUsuario;
            }

            // ....
        }
      #+END_SRC
*** Inyección por Setter (ó propiedad)
    - Seria similar que por la *inyección por constructor*, pero se puede ir cambiando durante el ciclo de vida del objeto

    #+BEGIN_SRC java
      public class Cliente{
          public void ejecutar(){
              SevicioAutenticacion servicioAutenticacion = new ServicioAutenticacion();

              servicioAutenticacion.servicioEncriptacion = new ServicioEncriptacionMD5();
              servicioAutenticacion.iniciarSesion(new Credenciales()); //

              servicioAutenticacion.servicioEncriptacion = new ServicioEncriptacionSha1();
              servicioAutenticacion.iniciarSesion(new Credenciales()); //
          }
      }
 
      // en esta clase aparece la "inyección de dependencia"
      public class ServicioAutenticacion{
          public IServicioEncriptacion servicioEncriptacion; // getter y setter

          public ResultadoInicioSesion iniciarSesion(Credenciales credenciales){ // <--- inyección de dependencia en el setter
              passwordHash = servicioEncriptacion.obtenerHash(credenciales.password);
              // ...
          }

      }
    #+END_SRC
*** Inyección por párametro
    #+BEGIN_SRC java
      public class Cliente{
          public void ejecutar(){
              ServicioAutenticacion servicioAutenticacion = new ServicioAutenticacion();

              servicioAutenticacion.iniciarSesion(new Credenciales(), new ServicioEncriptacionMD5()); // <---
          }
      }

      // en esta clase aparece la "inyección de dependencia" por parámetro
      public class ServicioAutenticacion{
          public ResultadoInicioSesion iniciarSesion(Credenciales credenciales, IServicioEncriptacion servicioEncriptacion){ // <---
              passwordHash = servicioEncriptacion.obtenerHash(credenciales.password);

              // ...
          }
      }
    #+END_SRC
*** Inyección por Interfaz
    declara el método que recibe por parámetro la dependencia, que luego debe definir quien implemente la interfaz
** (IoC) Inversión de Control
*** Conceptos
    #+BEGIN_QUOTE
    *(IoC) Inversion of Control:*
    Se debe "depender" de las *abstracciones* (/clases de alto nivel/), NO de las *implementaciones* (/clases de bajo nivel/)

    Se lo relaciona con el *principio de Hollywood*... por su famosos dicho de "NO nos llame, nosotros lo llamaremos" ;) 

    Es lo que hace la diferencia entre un *Framework* y una *biblioteca*
    #+END_QUOTE

    - Es un término genérico de "se invierte el flujo de control de un ALGO" ese algo puede ser..
      - el control gráfico (/un framework toma el control de la pantalla para mostrar algo/)
      - el control de _persistencia de datos_ (//)
      - el control de _creación de dependencias_ (la técnica DI, Inyección de Dependencias)
      - el control del ámbito de ejecución web (/más conocido como scope, cuando se delimita el alcance/)
    - Cuando se trata solo de la _creación de dependencias_, el *(IoC)* se especializa en la *inyección de dependencias*
      - cuando un objeto/programa cede el control a alguien más (a otros objetos ó a un framework)
*** Patrones para implementarlo
        Se puede implementar con alguno de los sig. patrones de diseño
        - Observer
        - Strategy
*** Contenedores de Inversión de Control (IoC Containers)
    - Resuelven el problema la jerarquia de dependencias (/cuando hay dependencias que dependen de muchas otras y estas de otras, ../)
** Contenedores de (IoC) Inversión de Control Vs Contenedores de (DI) Inyección de Dependencia/Servicios
   Se les debe indicar
   - Que objetos son inyectables
   - En que momento necesitaremos las dependencias
** Referencias Web
   1. http://martinfowler.com/articles/injection.html
   2. http://martinfowler.com/bliki/InversionOfControl.html
   3. http://www.manning.com/seemann/
   4. http://www.pluralsight.com/courses/principles-oo-design
* [TODO] Publisher (Consumer)
* [TODO] Singleton
* [TODO] Composite
* Referencias
** Referencias Web
  1. https://www.fdi.ucm.es/profesor/jpavon/poo/2.14pdoo.pdf
  2. https://www.baeldung.com/java-observer-pattern
  3. https://www.arquitecturajava.com/categoria/arquitectura/design-patterns/
  4. https://reactiveprogramming.io/blog/es/patrones-de-diseno/
  5. https://www.javatpoint.com/design-patterns-in-java
  6. https://www.tutorialspoint.com/design_pattern/index.htm
  7. https://sourcemaking.com/design_patterns
  8. https://refactoring.guru/design-patterns
  9. https://www.opencodez.com/category/java
  10. https://www.javacodegeeks.com/2015/09/java-design-patterns.html
  11. https://www.geeksforgeeks.org/abstract-factory-pattern/
  12. https://informaticapc.com/patrones-de-diseno/
  13. https://aprendeyprogramablog.wordpress.com/2016/07/10/ejemplo-abstract-factory/
  14. https://jesusramirezguerrero.com/2014/08/26/patrones-de-diseno-en-java/
** Referencias Repositorios
  1. https://github.com/miw-upm/apaw/tree/develop/src/main/java/es/upm/miw/pd
  2. https://github.com/eugenp/tutorials/tree/master/patterns/design-patterns-creational/src/main/java/com/baeldung
  3. https://gitlab.com/UAI-TCTD
** Referencias Youtube
   1. https://www.youtube.com/watch?v=PZ_fM3qCkc4&list=PLj2IVmcP-_QOuIKgInMyOKQWRbhrV3td6
   2. https://www.youtube.com/playlist?list=PLF206E906175C7E07
   3. https://www.youtube.com/watch?v=QiKrKNTdGGs&list=PLvimn1Ins-41Uiugt1WbpyFo1XT1WOquL
   4. https://www.youtube.com/watch?v=HFkZb1g8faA&list=PLJkcleqxxobUJlz1Cm8WYd-F_kckkDvc8
   5. https://www.youtube.com/watch?v=rjDddJqaLnk&list=PLj2IVmcP-_QNaYYCV7kWMpEBvoXu0JPt-
** Otras Referencias
  1. https://www.fdi.ucm.es/profesor/jpavon/poo/2.14pdoo.pdf
  2. https://picodotdev.github.io/blog-bitix/2020/12/para-que-sirve-la-palabra-clave-final-en-el-codigo-fuente-java/
  3. https://stackify.com/specify-handle-exceptions-java/
  4. https://www.seas.es/blog/informatica/agregacion-vs-composicion-en-diagramas-de-clases-uml/
** Referencias Interesantes
   1. https://www.arquitecturajava.com/java-8-lambda-expressions/
   2. https://www.arquitecturajava.com/uso-de-java-generics/
   3. https://www.adictosaltrabajo.com/2015/03/02/optional-java-8/
   4. https://www.arquitecturajava.com/java-generics-uso-de-wildcard/
